{"./":{"url":"./","title":"Introduce","keywords":"","body":"《Introduce》 试问天人仙人 谁敢来此人间996 关于 我 Hey，I'm Ariescat，一只在广州苟活的程序猿。 九〇后，性别男，直男，爱好女。 有时文艺，有时严肃，有时逗比，怕生。 有时候看书，喜欢折腾一些东西。 现在是一个废物。 关于 Awesome 这是我利用 GitBook 搭建的笔记记录：📖 Ariescat's Awesome 此非大而全的知识图谱，只是在下踏上编程的不归路后，陆陆续续把学到的知识记录于此，以便于温故知新 （我还搭建了个小破站 Ariescat's Blog，偶尔想起来的时候也会写写博客的） 栖身之所： 现源代码托管于 Github，由 GitHub 自动部署于 Vercel、Coding Pages。 为何选择 Vercel? 折腾的心不想受限于 Github Page； 至于 Coding Pages，那是因为以上平台对墙内的世界并不友好，访问速度让人 jio 急。 （现在境内的线路会自动分发至 Coding Pages，并由 腾讯云的 CDN 加速 🚀🚀 ） Timeline： 2021-12-25：由于 Coding Page 将于年底停止提供「网站托管」服务，现已迁移至某云的 Serverless 托管。 2021-09-30：引入 gittalk 评论系统。 2021-09-18：采用 Github Actions，自动持续集成部署，解放双手~~ 此后只要提交到 Github 就行啦。 2021-09-17：完成模块拆分，细分笔记。 2021-09-16：由于部署太繁琐，采用了 gh-pages - npm (npmjs.com)，并编写了脚本进行部署。 2021-09-15：把 源笔记 迁移至此，小站此步；由本地搭建 gitbook-cli 环境，build 后手动推送页面到仓库的 gh-pages 分支，部署于 Github Pages。 感谢 GitBook：GitBook 简明教程 在线排版工具：TTS (cyc2018.github.io) 表格转HTML：要想 MarkDown 中插入复杂表格时，可以先在 word 或 excel 中把表格写好，然后在如下网站进行转化为标记对形式：http://pressbin.com/tools/excel_to_html_table/index.html Copyright © Ariescat all right reserved，powered by Gitbook最后修改时间： 2022-03-08 13:30 "},"Awesome/Java.html":{"url":"Awesome/Java.html","title":"Java 基础","keywords":"","body":"《不归路之Java》 思想是灵魂， 实现是形式。 Java 基础 基本类型 强转 long 转 int 注意：最高位为 1 强转会为负数！ 如：正数 2147483648（long 类型）强转 int 会变成负数，（int）0x80000000 => -2147483648(Integer.MIN_VALUE) 无符号类型 java 中无符号类型的解决方案 Java8 包装类 新增 无符号运算方法 byte 转换 int 时与 0xff 进行与运算的原因 Integer Java Integer(-128~127)值的==和equals比较产生的思考 - CSniper - 博客园 (cnblogs.com) 浮点数怎么存储 计算机与数学 —— 雷神之锤3源码中的快速逆平方根算法 String 正则表达式 Java 中的 String 有没有长度限制？ 数组呢？ StringJoiner（Java 8 中提供的可变字符串类） char JAVA 的 char 内部编码为 UTF-16 ，而与 Charset.defaultCharset() 无关 String s = new String(\"a\") 到底产生几个对象？ 对于通过 new 产生一个字符串（\"a\"）时，会先去常量池中查找是否已经有了”a”对象，如果没有则在常量池中创建一个此字符串对象，然后堆中再创建一个常量池中此\"a\"对象的拷贝对象。 也就是说准确答案是产生了一个或两个对象，如果常量池中原来没有\"a\"，就是两个。反之就是一个。 是的！如果面试官问到，回答一个或两个即可，但是…毕竟…毕竟 毕竟我和在座的各位都是人才，Java 知识底蕴不能如此短浅，这题还没谢幕我们还能对面试官多哔哔几句：字符串常量池在不同版本的 jvm 中可能位置不同，那么这又是一个老梗了。（在 JDK6.0 及之前版本，字符串常量池是放在 Perm Gen 区 (也就是方法区) 中；在 JDK7.0 版本，字符串常量池被移到了堆中了） 扩展： intern 方法 深入解析 String#intern 关键点是 jdk7 中常量池不在 Perm 区域了，这块做了调整。常量池中不需要再存储一份对象了，可以直接存储堆中的引用 此外，Java 中的常量池有字符串常量池、class 常量池和运行时常量池。原文 常量池会被回收吗？ 枚举 枚举详解之 EnumSet、EnumMap 用法 RegularEnumSet里面有这样一行代码： elements = -1L >>> -universe.length; 无符号右移一个负数！是一个负移位量！ 换个例子看一下：-1 >>> -5 其实等同 -1 >>> 27；-1L >>> -5 等同 -1L >>> 59 如果移位量超过位数：-1 >>> 32 其实等同 -1 >>> 0；-1 >>> 33 等同 -1 >>> 1 数组 二维数组按行和按列遍历效率？ CPU 高速缓存 内存分页调度 参考：二维数组按行和按列遍历效率醒来明月的博客-CSDN 博客二维数组访问效率 运算符 左移 右移 操作符 描述 例子 按位左移运算符。左操作数按位左移右操作数指定的位数。 A >> 按位右移运算符。左操作数按位右移右操作数指定的位数。 A >> 2 得到 15 即 1111 >>> 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 A>>>2 得到 15 即 0000 1111 优先级 运算符优先级，左右优先级 日期与时间 Date 和 Calendar，LocalDateTime（Java8），ZonedDateTime（时区），Instant LocalDate/LocalTime 类 Java 8 新增了 LocalDate 和 LocalTime 接口，为什么要搞一套全新的处理日期和时间的 API？因为旧的 java.util.Date 实在是太难用了： java.util.Date 月份从0开始，一月是 0，十二月是 11，变态吧！java.time.LocalDate 月份和星期都改成了 enum，就不可能再用错了。 java.util.Date 和 SimpleDateFormatter 都不是线程安全的，而 LocalDate 和 LocalTime 和最基本的 String 一样，是不变类型，不但线程安全，而且不能修改。 Instant Instant 获取的是 UTC 的时间，而 Date 是根据当前服务器所处的环境的默认时区来获取的当前时间。 泛型 擦拭，extends 通配符，super 通配符 问题： 为什么泛型编译期擦除了，getGenericSuperclass 或反射等还能获取得到？ Java 泛型类型擦除与运行时类型获取 - linghu_java - 博客园 (cnblogs.com) 异常 Error 和 Exception 的区别 finally语句到底是在return之前还是之后执行？ 不管有木有出现异常，finally块中代码都会执行； 当try和catch中有return时，finally仍然会执行； finally是在return语句执行之后，返回之前执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，不管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值），所以函数返回值是在finally执行前就已经确定了； finally中如果包含return，那么程序将在这里返回，而不是try或catch中的return返回，返回值就不是try或catch中保存的返回值了。 位运算 ^“异或运算”的特殊作用： （1）使特定位翻转找一个数，对应 X 要翻转的各位，该数的对应位为 1，其余位为零，此数与 X 对应位异或即可。 例：X=10101110，使 X 低 4 位翻转，用 X ^ 0000 1111 = 1010 0001 即可得到。 （2）与 0 相异或，保留原值 ，X ^ 0000 0000 = 1010 1110。 ~取反: 注意最高位也会取反 Math log 在 Java 中求 log2N，首先要弄明白一个初中学到的公式 log2N=logeN/loge2 ，logeN 代表以 e 为底的 N 的对数，loge2 代表以 e 为底的 2 的对数 在 java.lang.math 类中的 log(double a) 代表以 e 为底的 a 的对数，因此 log2N 在 Java 中的表示为 log((double)N)/log((double)2) pow Java 高级 数据结构 位集合（BitSet） JDK 中的 BitSet 集合对是布隆过滤器中经常使用的数据结构Bitmap的相对简单的实现。BitSet 采用了Bitmap 的算法思想。 向量（Vector） 线程安全 栈（Stack） 字典（Dictionary） 哈希表（Hashtable） 属性（Properties） 集合容器 HashMap Java 集合比如说 HashMap 和 ConcurrentHashMap 我觉得，最好在平时能去耐心读一下源码，搜一搜相关的博客，最好能知道每个参数为什么设置成这么大？有什么好处？为什么？ hash 算法 详细梳理 JAVA7 和 JAVA8 HashMap 的 hash 实现 优化 最近它有两个主要的更新——一个在 Java 7u40 版本中对于空 map 的共享的底层存储，以及在 Java 8 中将底层 hash bucket 链接成为哈希树（改进更差情况下的性能）。 jdk1.7 中的线程安全问题 resize 死循环： ConcurrentModificationException 疫苗：JAVA HASHMAP 的死循环 jdk8 中是如何解决 jdk7 中的 HashMap 死循环的 IdentityHashMap 和 HashMap 最大的不同，就是使用==而不是 equals 比较 key WeakHashMap 会内存泄漏？ ConcurrentSkipListMap 跳表 ConcurrentSkipListMap ConcurrentHashMap 死循环 ConcurrentHashMap BUG 死锁 死锁（该问题由 fly 提出并收录） ConcurrentHashMap map = new ConcurrentHashMap<>(); map.put(1, 1); map.put(2, 2); Thread t1 = new Thread(() -> { LockSupport.parkNanos(TimeUnit.SECONDS.toNanos(2)); map.computeIfAbsent(4, key -> { map.clear(); System.out.println(\"4\"); return key; }); }); Thread t2 = new Thread(() -> { LockSupport.parkNanos(TimeUnit.SECONDS.toNanos(2)); map.computeIfAbsent(3, key -> { map.clear(); System.out.println(\"3\"); return key; }); }); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(\"finish\"); ConcurrentHashMap 1194 行会死锁 TreeMap TreeSet 同理，红黑树实现 List CopyOnWriteArrayList 附：Redis 写快照的时候，用到了 Linux 底层的 Copy-On-Write 技术 一个著名 BUG c.toArray might (incorrectly) not return Object[] (see 6260652) 原文 java.util.ArrayList 元素类型为Object[] elementData，toArray()方法实质返回Object[] java.util.Arrays.ArrayList 元素类型为E[] a，toArray()方法实质返回E[] 因此，虽然List的toArray接口表面都返回 Object[]，但他们的实质返回值还是有差的。所以我们不能将其他类型的对象，放进java.util.Arrays.ArrayList#toArray()返回的数组中。 List list = Arrays.asList(\"abc\"); // class java.util.Arrays$ArrayList System.out.println(list.getClass()); Object[] objArray = list.toArray(); // class [Ljava.lang.String; System.out.println(objArray.getClass()); // cause ArrayStoreException objArray[0] = new Object(); Queue 接口的几个主要方法 add/offer, remove/poll, element/peek DelayQueue ScheduledThreadPoolExecutor 其任务队列默认是 DelayedWorkQueue 的变种 Arrays 几个类 TimSort，ComparableTimSort，DualPivotQuicksort 几个方法 binarySort 折半插入排序 mergeSort Koloboke （第三方的集合库） 原始类型集合库Koloboke，避免大量的装箱拆箱，Koloboke 的目标是替换标准的 Java 集合和流的 API，提供更高效的实现。 同类型的还有 HPPC，Eclipse Collections 等。 线程安全的类 另看：并发容器 fail-fast 和 fail-safe 快速失败(fail-fast)和安全失败(fail-safe)的区别 - 那啥快看 - 博客园 (cnblogs.com) 代理 按照代理的创建时期，代理类可以分为两种。 静态代理：由程序员创建或特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class 文件就已经存在了。 动态代理：在程序运行时，运用反射机制动态创建而成。 动态代理方案 jdk 动态代理 cglib 动态代理 JDK 的动态代理机制只能代理实现了接口的类，而不能实现接口的类就不能实现 JDK 的动态代理，cglib 是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对 final 修饰的类进行代理。 Cglib 与 JDK 动态代理 javassist 动态代理 ASM 字节码 javassist 字节码 深入理解 RPC 之动态代理篇 - 徐靖峰|个人博客 (cnkirito.moe) Q&A 为什么 cglib 为什么生成两个 fastclass，methodProxy.invokeSuper(“代理对象”, args) 和 methodProxy.invoke(“原对象”, args) 虽然底层分别调用两个不同的 fastclass，但结果是一样的。 // 自定义 Cglib 代理拦截 public class DemoInterceptor implements MethodInterceptor { // @param o cglib 生成的代理对象 // @param method 被代理对象方法 // @param objects 方法入参 // @param methodProxy 代理方法 public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { System.err.println(\"intercept\"); // invokeSuper，o 为 cglib 生成的代理对象 return methodProxy.invokeSuper(o, objects); } } // org.springframework.aop.framework.CglibAopProxy.CglibMethodInvocation private static class CglibMethodInvocation extends ReflectiveMethodInvocation { private final MethodProxy methodProxy; private boolean protectedMethod; public CglibMethodInvocation(Object proxy, Object target, Method method, Object[] arguments, Class targetClass, List interceptorsAndDynamicMethodMatchers, MethodProxy methodProxy) { super(proxy, target, method, arguments, targetClass, interceptorsAndDynamicMethodMatchers); this.methodProxy = methodProxy; this.protectedMethod = Modifier.isProtected(method.getModifiers()); } protected Object invokeJoinpoint() throws Throwable { // invoke，target 为原对象 return this.protectedMethod ? super.invokeJoinpoint() : this.methodProxy.invoke(this.target, this.arguments); } } 可扩展看看 Spring 的 JdkDynamicAopProxy，其实本质上 Spring 对代理的处理都差不多 反射 Class Class类 与 Class 对象 Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的，因此不能显式地声明一个Class对象。 虚拟机为每种类型管理一个独一无二的Class对象。也就是说，每个类（型）都有一个Class对象。运行程序时，Java虚拟机(JVM)首先检查是否所要加载的类对应的Class对象是否已经加载。如果没有加载，JVM就会根据类名查找.class文件，并将其Class对象载入。 基本的 Java 类型（boolean、byte、char、short、int、long、float 和 double）和关键字 void 也都对应一个 Class 对象。 每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。 Class 对象的获取方式 Class.forName(\"类名字符串\") 类名.class 实例对象.getClass() 关键字 instanceof VS Class.isInstance（参数） System.err.println(son instanceof Parent); System.err.println(Parent.class.isInstance(son)); Class 的 getSuperclass 与 getGenericSuperclass getGenericSuperclass 会包含该超类的泛型。 判断当前类是什么类 boolean isLocalClass(); //判断是不是局部类，也就是方法里面的类，其实现：isLocalOrAnonymousClass() && !isAnonymousClass(); boolean isLocalOrAnonymousClass(); boolean isMemberClass(); //判断是不是成员内部类，也就是一个类里面定义的类 boolean isAnonymousClass(); //判断当前类是不是匿名类，一般为实例化的接口或实例化的抽象类 boolean isAnnotation();// 判断 Class 对象是否是注解类型 boolean isPrimitive(); // 判断 Class 是否为原始类型（int，double 等） boolean isSynthetic(); // 判断是否由 Java 编译器生成（除了像默认构造函数这一类的）的方法或者类，Method 也有这个方法 参考： Java 中冷门的 synthetic 关键字原理解读 - 老白讲互联网 - 博客园 (cnblogs.com) 返回字符串 (String) 的方法 String getCanonicalName(); //返回 Java Language Specification 中所定义的底层类的规范化名称 String getName(); //以 String 的形式返回此 Class 对象所表示的实体（类、接口、数组类、基本类型或 void）名称（全限定名：包名.类名）。 String getSimpleName(); //返回源代码中给出的底层类的简称。 String toString(); //将对象转换为字符串。 Class.forName 和 ClassLoader 的区别 都可用来对类进行加载。 不同： 1）Class.forName() 除了将类的.class 文件加载到 jvm 中之外，还会对类进行解释，执行类中的 static 块，还会执行给静态变量赋值的静态方法 2）classLoader 只干一件事情，就是将.class 文件加载到 jvm 中，不会执行 static 中的内容,只有在 newInstance 才会去执行 static 块。 使用 Class.getResource 和 ClassLoader.getResource 方法获取文件路径 对于class.getResource(path)方法，其中的参数 path 有两种形式，一种是以“/”开头的，另一种是不以\"/\"开头 Class.getClassLoader().getResource(String path)，该方法中的参数 path 不能以“/“开头，path 表示的是从 classpath 下获取资源的 Method Method.invoke() 的实现原理 假笨说-从一起 GC 血案谈到反射原理 获取 Method： reflectionData，这个属性主要是 SoftReference 的 我们每次通过调用 getDeclaredMethod 方法返回的 Method 对象其实都是一个新的对象，所以不宜多调哦，如果调用频繁最好缓存起来。不过这个新的方法对象都有个 root 属性指向 reflectionData 里缓存的某个方法，同时其 methodAccessor 也是用的缓存里的那个 Method 的 methodAccessor。 Method 调用： 其实 Method.invoke 方法就是调用 methodAccessor 的 invoke 方法 MethodAccessor 的实现： 所有的方法反射都是先走 NativeMethodAccessorImpl，默认调了15次之后，才生成一个 GeneratedMethodAccessorXXX 类 而 GeneratedMethodAccessorXXX 的类加载器会 new 一个 DelegatingClassLoader(var4)，之所以搞一个新的类加载器，是为了性能考虑，在某些情况下可以卸载这些生成的类，因为类的卸载是只有在类加载器可以被回收的情况下才会被回收的 并发导致垃圾类创建： 假如有 1000 个线程都进入到创建 GeneratedMethodAccessorXXX 的逻辑里，那意味着多创建了 999 个无用的类，这些类会一直占着内存，直到能回收 Perm 的 GC 发生才会回收（关于元空间的回收看JVM内存管理） 后来发现JDK17加了个乐观锁判断 U.compareAndSetInt(this, GENERATED_OFFSET, 0, 1)，应该是修复过这个问题了（但JDK8并没有修复） 其他 JVM 相关文章: 该文章最后有其他 JVM 相关文章，感觉是干货 反射代理类加载器的潜在内存使用问题！！ 大量的类加载器 sun/reflect/DelegatingClassLoader，用来加载 sun/reflect/GeneratedMethodAccessor 类，可能导致潜在的占用大量本机内存空间问题，应用服务器进程占用的内存会显著增大。 其他链接 JDK1.8里Method.invoke()的实现原理 - 简书 (jianshu.com) MethodHandle 反射获取的信息比 MethodHandle 要多。 反射是模拟 java 代码层面的调用，MethodHandle 是模拟字节码层面的调用。 MethodHandle 和 反射 相比好处是： 调用 invoke() 已经被 JVM 优化，类似直接调用一样。 性能好得多，类似标准的方法调用。 当我们创建 MethodHandle 对象时，实现方法检测，而不是调用 invoke() 时。 看 指令集 VarHandle VarHandle主要用于动态操作数组的元素或对象的成员变量。VarHandle与MethodHandle非常类似，它也需要通过MethodHandles来获取实例。 创建和销毁对象 单例 与 序列化 一般来说，一个类实现了 Serializable 接口，我们就可以把它往内存地写再从内存里读出而\"组装\"成一个跟原来一模一样的对象。不过当序列化遇到单例时，这里边就有了个问题：从内存读出而组装的对象破坏了单例的规则。单例是要求一个 JVM 中只有一个类对象的，而现在通过反序列化，一个新的对象克隆了出来。 解决方案：加上 readResolve() 方法 public final class MySingleton implements Serializable { private MySingleton() { } private static final MySingleton INSTANCE = new MySingleton(); public static MySingleton getInstance() { return INSTANCE; } private Object readResolve() throws ObjectStreamException { // instead of the object we're on, // return the class variable INSTANCE return INSTANCE; } } 对象实例化顺序 父类的静态成员变量和静态代码块加载 子类的静态成员变量和静态代码块加载 父类成员变量和方法块加载 父类的构造函数加载 子类成员变量和方法块加载 子类的构造函数加载 参考： Java 类的实例化顺序 java 类实例化顺序+经典的面试题 测试：com.ariescat.metis.base.jdk.TestSameField java 中父类与子类有相同属性调谁？ 继承中： 属性：不可被重写，只会被隐藏 方法：会被重写，不会隐藏 多态中， 成员变量无论编译和运行，都参考左边 (引用型变量所属的类)。 也就是说 Fu f = new Zi();System.out.println(f.age); 打印的还是父类的值。 参考： java 中父类与子类有相同属性调谁？取决于左边 父类和子类同时存在相同属性 BeanUtils 的 copyProperties 复制 对象引用 WeakReference 看 ThreadLocal 源码的时候，其中嵌套类 ThreadLocalMap 中的 Entry 继承了 WeakReference，为了能搞清楚 ThreadLocal，只能先了解下了 WeakReference： WeakReference 如字面意思，弱引用， 当一个对象仅仅被 WeakReference（弱引用）指向, 而没有任何其他 strong reference（强引用）指向的时候, 如果这时 GC 运行, 那么这个对象就会被回收，不论当前的内存空间是否足够，这个对象都会被回收。 注意：回收的是 WeakReference 引用的对象！若存在 ReferenceQueue 队列，WeakReference 本身会入队，但此时 get()==null WeakHashMap SoftReference 若清楚了上面的原理，SoftReference 只是生命周期变成内存将要被耗尽的时候。 from 关于 SoftReference 被回收的时机 下面，我们来总结一下: 1.当发生 GC 时，虚拟机可能会回收 SoftReference 对象所指向的软引用，是否被回收取决于该软引用是否是新创建或近期使用过。 2.在虚拟机抛出 OutOfMemoryError 之前，所有软引用对象都会被回收。 3.只要一个软引用对象由一个强引用指向，那么即使是 OutOfMemoryError 时，也不会被回收。 from JVM - 优化案例（SoftRefLRUPolicyMSPerMB） 那么 SoftReference 对象到底在 GC 的时候要不要回收是通过什么公式来判断的呢？ 是如下的一个公式： clock - timestamp 这个公式的意思就是说，“clock - timestamp”代表了一个软引用对象他有多久没被访问过了，freespace 代表 JVM 中的空闲内存空间，SoftRefLRUPolicyMSPerMB 代表每一 MB 空闲内存空间可以允许 SoftReference 对象存活多久。 guava cache： CacheBuilder.newBuilder().softValues().build() 当然 softValues() 可以替换成 weakKeys() / weakValues() ... 实现原理可具体看 com.google.common.cache.LocalCache.Strength LRU 缓存实现 (Java) 软引用和弱引用 被软引用关联的对象只有在内存不足时才会被回收，而被弱引用关联的对象在JVM进行垃圾回收时总会被回收。针对上面的特性，软引用适合用来进行缓存，当内存不够时能让JVM回收内存，弱引用能用来在回调函数中防止内存泄露。因为回调函数往往是匿名内部类，隐式保存有对外部类的引用，所以如果回调函数是在另一个线程里面被回调，而这时如果需要回收外部类，那么就会内存泄露，因为匿名内部类保存有对外部类的强引用。 对象序列化 Serializable readResolve() 与 单例 ObjectInputStream、ObjectOutputStream 看看readObject与writeObject方法源码 对象拷贝 深复制（深克隆）和浅复制（浅克隆） BeanUtils 对象属性 copy 的性能对比以及源码分析 拷贝方式 对象数量: 1 对象数量: 1000 对象数量: 100000 对象数量: 1000000 Hard Code 0 ms 1 ms 18 ms 43 ms cglib.BeanCopier 111 ms 117 ms 107 ms 110 ms spring.BeanUtils 116 ms 137 ms 246 ms 895 ms apache.PropertyUtils 167 ms 212 ms 601 ms 7869 ms apache.BeanUtils 167 ms 275 ms 1732 ms 12380 ms 热更新 自定义类加载器 探秘 Java 热部署 CSDN·自定义 classloader 实现 JAVA 热替换 java.lang.instrument 类重新定义，这是 Instrumentation 提供的基础功能之一，这个类很早就出了，redefineClasses 这个方法可以更新方法级别的代码，但是不会触发一个类的初始化方法。 游戏服务器之 Java 热更新 动态加载 class 文件 JVM 源码分析之 javaagent 原理完全解读 探秘 Java 热部署二（Java agent premain） 探秘 Java 热部署三（Java agent agentmain） 第三方工具 Arthas的使用 Github · HotswapAgent 脚本语言 groovy 使用 groovy 类加载器重载 java 代码 重载的 java 文件可以直接使用源文件，无需编译为 class JVMTI JVM Tool Interface，是jvm暴露出来的一些供用户扩展的接口集合，JVMTI是基于事件驱动的，JVM每执行到一定的逻辑就会调用一些事件的回调接口（如果有的话），这些接口可以供开发者去扩展自己的逻辑。 JVMTIAgent JVMTIAgent其实就是一个动态库，利用JVMTI暴露出来的一些接口来干一些我们想做但是正常情况下又做不到的事情，不过为了和普通的动态库进行区分，它一般会实现如下的一个或者多个函数： JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *vm, char *options, void *reserved); JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM* vm, char* options, void* reserved); JNIEXPORT void JNICALL Agent_OnUnload(JavaVM *vm); JVM启动参数：-agentlib:libname[=options]、-agentpath:pathname[=options]。 比如：-agentlib:hprof，会搜到环境变量PATH中的dll/so库；而-agentpath会按全路径装载本地库，不再搜索PATH中的路径，其他功能和agentlib相同。 javaagent javaagent是由一个叫做instrument的JVMTIAgent（linux下对应的动态库是libinstrument.so）来实现的，另外instrument agent还有个别名叫JPLISAgent（Java Programming Language Instrumentation Services Agent），从这名字里也完全体现了其最本质的功能：就是专门为java语言编写的插桩服务提供支持的。 JVM启动参数：-javaagent:jarpath[=options] 参考：java agent基础原理_ancinsdn的博客 System#exit 注册的关闭勾子会在以下几种时机被调用到 程序正常退出 最后一个非守护线程执行完毕退出时 System.exit 方法被调用时 程序响应外部事件 程序响应用户输入事件，例如在控制台按 ctrl+c(^+c) 程序响应系统事件，如用户注销、系统关机等 这种方法永远不会正常返回。 意味着该方法不会返回；一旦一个线程进入那里，就不会再回来了。 链接： Java System#exit 无法退出程序的问题探索 java System.exit(0) 结束不了其他线程? 最后一楼说了：将 A 线程变为 while(true) 一直执行，就会发现 A 线程也会中止。两个线程各自执行，之前都循环十次，A 线程可能在 B 线程调用 System.exit(0) 之前就执行完了 ServiceLoader Java 中 SPI 全称为（Service Provider Interface，服务提供者接口） 该类通过在资源目录 META-INF/services 中放置提供者配置文件来标识服务提供者。 应用场景： JDBC 驱动加载 java.sql.DriverManager#loadInitialDrivers这里调用了ServiceLoader.load(Driver.class); 因此只要 pom 引入了mysql-connector-java这个包，就会加载jar包下META-INF/services/java.sql.Driver文件中的com.mysql.jdbc.Driver类，而com.mysql.jdbc.Driver在静态代码块里往DriverManager注册了自己的驱动。所以以后就不用写下面的 a 段代码啦。 //a.导入驱动，加载具体的驱动类 Class.forName(\"com.mysql.jdbc.Driver\"); //b.与数据库建立连接 connection = DriverManager.getConnection(URL, USERNAME, PASSWORD); netty/Java 的 NIO 采用 SelectorProvider 创建：io.netty.channel.nio.NioEventLoop#provider 而java.nio.channels.spi.SelectorProvider#provider采用了 SPI Dubbo 的扩展点加载 Dubbo 的 SPI 扩展是自己实现的，在启动加载的时候会依次从以下目录中读取配置文件： META-INF/dubbo/internal/、META-INF/dubbo/、META-INF/services/ ——《高可用可伸缩微服务架构：基于 Dubbo、Spring Cloud 和 Service Mesh》3.2.3 节 Dubbo Extension 机制 Observable 操作 Vector 型变量 obs 的四个方法都加有同步关键字，Vector 类型为线程安全的，而上述四个方法为什么还要加同步关键字呢？ Java 注解处理器 Annotation Processor javax.annotation.processing.AbstractProcessor 编译时执行 JMX JMX 是 Java Management Extensions，它是一个 Java 平台的管理和监控接口。 了解不深== 启动 jsvc 在 linux 上以服务的方式启动 java 程序，需要提前安装 jsvc。linux 是利用 daemon(jsvc) 构建 java 守护进程。 语法糖 有认真了解过 Java 的语法糖吗？ Java 中的 10 颗语法糖 字符编解码 字符集 ASCII Unicode 目前 Unicode 字符分为 17 组编排，0x0000 至 0x10FFFF,每组称为平面（Plane）,每个面拥有 65536 个码位，共 1114112 个。 字符编码 UTF-32、UTF-16 和 UTF-8 是 Unicode 标准的编码字符集的字符编码方案 附： Java 的char内部编码为UTF-16，而与Charset.defaultCharset()无关。 看 Unicode 编码理解 可知UTF-16编码完全可以满足 Unicode 的 17 组编排（平面），因为有平面 0 的 0xD800-0xDFFF 代理区。 关于 java 中 char 占几个字节，汉字占几个字节，这里指出 Java 中的char是占用两个字节，只不过有些字符需要两个 char 来表示，同时这篇博客也给了一个官方 Oracle 链接里面明确的说明了值在 16 位范围之外且在 0x10000 到 0x10FFFF 范围内的字符称为补充字符，并定义为一对 char 值。 测试代码： public static void main(String[] args) { char[] c = new char[]{'一'}; System.err.println(Integer.toHexString(c[0])); String s = new String(c); // String#length事实上调用了char[].length System.err.println(s + \" \" + s.length()); String str = \"一\"; System.err.println(str + \" \" + str.length()); // Unicode编码 汉字扩展B '𠀀' 字 c = new char[]{'\\uD840', '\\uDC00'}; s = new String(c); System.err.println(s + \" \" + s.length()); str = \"\\uD840\\uDC00\"; System.err.println(str + \" \" + str.length()); // 输出：由输出可见这个字用了两个char来存 // 一 1 // 一 1 // 𠀀 2 // 𠀀 2 } UniCode 编码表 汉字 unicode 编码范围 参考博客： 吴秦（Tyler）字符集和字符编码（Charset & Encoding） 廖雪峰 字符串和编码 该文有简单有效的解释了： 在计算机内存中，统一使用 Unicode 编码，当需要保存到硬盘或者需要传输的时候，就转换为 UTF-8 编码。 用记事本编辑的时候，从文件读取的 UTF-8 字符被转换为 Unicode 字符到内存里，编辑完成后，保存的时候再把 Unicode 转换为 UTF-8 保存到文件： 浏览网页的时候，服务器会把动态生成的 Unicode 内容转换为 UTF-8 再传输到浏览器： 所以你看到很多网页的源码上会有类似的信息，表示该网页正是用的 UTF-8 编码。 Base64 编码： Base64 编码本质上是一种将二进制数据转成文本数据的方案。对于非二进制数据，是先将其转换成二进制形式，然后每连续 6 比特（2 的 6 次方=64）计算其十进制值，根据该值在上面的索引表中找到对应的字符，最终得到一个文本字符串。 常见问题处理之 Emoji 所谓 Emoji 就是一种在 Unicode 位于\\u1F601–\\u1F64F 区段的字符。这个显然超过了目前常用的 UTF-8 字符集的编码范围\\u0000–\\uFFFF。Emoji 表情随着 IOS 的普及和微信的支持越来越常见。 那么 Emoji 字符表情会对我们平时的开发运维带来什么影响呢？最常见的问题就在于将他存入 MySQL 数据库的时候。一般来说 MySQL 数据库的默认字符集都会配置成 UTF-8，mysql 支持的 utf8 编码最大字符长度为 3 字节，而 utf8mb4 在 5.5 以后才被支持，也很少会有 DBA 主动将系统默认字符集改成 utf8mb4。那么问题就来了，当我们把一个需要 4 字节 UTF-8 编码才能表示的字符存入数据库的时候就会报错：ERROR 1366: Incorrect string value: '\\xF0\\x9D\\x8C\\x86' for column 。 如果认真阅读了上面的解释，那么这个报错也就不难看懂了。我们试图将一串 Bytes 插入到一列中，而这串 Bytes 的第一个字节是\\xF0 意味着这是一个四字节的 UTF-8 编码。但是当 MySQL 表和列字符集配置为 UTF-8 的时候是无法存储这样的字符的，所以报了错。 那么遇到这种情况我们如何解决呢？有两种方式：升级 MySQL 到 5.6 或更高版本，并且将表字符集切换至 utf8mb4。第二种方法就是在把内容存入到数据库之前做一次过滤，将 Emoji 字符替换成一段特殊的文字编码，然后再存入数据库中。之后从数据库获取或者前端展示时再将这段特殊文字编码转换成 Emoji 显示。第二种方法我们假设用--1F601--来替代 4 字节的 Emoji，那么具体实现 python 代码可以参见Stackoverflow 上的回答 补码 补码(为什么按位取反再加一)：告诉你一个其实很简单的问题 原文 其核心思想就是：一个正数对应的负数（也就是俩相反数），这两个数的二进制编码加起来必须等于 0 才对 设计模式 六大设计原则 单一职责原则(Single Responsibility Principle - SRP) 开放封闭原则(Open Closed Principle - OCP) 里氏替换原则(Liskov Substitution Principle - LSP) 最少知识原则(Least Knowledge Principle - LKP) 接口隔离原则(Interface Segregation Principle - ISP) 依赖倒置原则(Dependence Inversion Principle - DIP) 设计模式 单例 double check volatile 禁止new的指令重排 参考： Java开发中的23种设计模式详解(转) - maowang - 博客园 (cnblogs.com) 反模式 上帝类(God Class)，这个类里面控制了很多其他的类，同时也依赖其他很多类。整个类不光负责自己的主要单一功能，而且还负责了其他很多功能，包括一些辅助功能。 Swing/Awt EventQueue 与 AWTEvent from https://github.com/jzyong/game-server.git game-tool/src/main/java/com/jzy/game/tool/db/DBTool.java java.awt.EventQueue.invokeLater EventQueue里有一条dispatchThread线程，在postEventPrivate里检测为 null 则进行初始化，然后一直调用pumpEvents取出优先级最高的AWTEvent进行分发： eq.dispatchEvent(event); 如java.awt.Component#dispatchEventImpl里会触发各种监听 Polygon，区域超区校验 Java IO IO 流 对文件进行操作：FileInputStream（字节输入流），FileOutputStream（字节输出流），FileReader（字符输入流），FileWriter（字符输出流） 2020 年 3 月 17 日追加： FileReader，可以理解成他把 FileInputStream 和 Decoder 封装了起来，本质上还是用 FileInputStream 读了一层字节流 byte[] (这里的 read 是一个 native 方法)，然后通过 Decoder 把他转成了 char[]。 BufferedReader，他默认开辟了一份 defaultCharBufferSize = 8192 长度的 cb[] 数组（缓冲区），读之前会把这个数组fill()满，之后都是操作这个数组，操作完了就再次更新数组，提高数据访问的效率。 测试代码：study-metis: com.ariescat.metis.base.io.iostream.Test 对管道进行操作：PipedInputStream（字节输入流），PipedOutStream（字节输出流），PipedReader（字符输入流），PipedWriter（字符输出流） PipedInputStream 的一个实例要和 PipedOutputStream 的一个实例共同使用，共同完成管道的读取写入操作，主要用于线程操作。 有空看看这里的实现 简介,源码分析和示例 在一个线程里使用 PipedInputStream 和 PipedOutputStream 会造成死锁：这意味着，如果你用同一个线程既读又写（read() 和 write() 方法是阻塞的方法），那么就会造成这个线程的死锁。 字节/字符数组：ByteArrayInputStream，ByteArrayOutputStream，CharArrayReader，CharArrayWriter 在内存中开辟了一个字节或字符数组。 Buffered 缓冲流：BufferedInputStream，BufferedOutputStream，BufferedReader，BufferedWriter 带缓冲区的处理流，缓冲区的作用的主要目的是：避免每次和硬盘打交道，提高数据访问的效率。 转化流： InputStreamReader：在读入数据的时候将字节转换成字符。 OutputStreamWriter：在写出数据的时候将字符转换成字节。 数据流：DataInputStream，DataOutputStream 因为平时若是我们输出一个 8 个字节的 long 类型或 4 个字节的 float 类型，那怎么办呢？可以一个字节一个字节输出，也可以把转换成字符串输出，但是这样转换费时间，若是直接输出该多好啊，因此这个数据流就解决了我们输出数据类型的困难。数据流可以直接输出 float 类型或 long 类型，提高了数据读写的效率。 打印流：printStream，printWriter 一般是打印到控制台，可以进行控制打印的地方和格式，其中的 print 方法不会抛出异常，可以通过 checkError 方法来查看异常。 对象流：ObjectInputStream，ObjectOutputStream 把封装的对象直接输出，而不是一个个在转换成字符串再输出。 RandomAccessFile 随机访问文件 java.io 包中是一个特殊的类, 既可以读文件，也可以写文件。 有空也要看看这里的实现，log4j2 的 Appender 里就有这个：RandomAccessFileAppender、RollingRandomAccessFileAppender RandomAccessFile 的绝大多数功能，但不是全部，已经被 JDK 1.4 的 nio 的内存映射文件(memory-mapped files)给取代了，你该考虑一下是不是用\"内存映射文件\"来代替 RandomAccessFile 了。 ZipInputStream、ZipOutputStream 读取 zip 文档 getNextEntry、putNextEntry 得到或创建 ZipEntry 对象。 close() 为什么要用 close() 关掉流？ 有些资源 GC 回收不掉？ Path/Files IO 操作你还在用 File 吗，该拥抱 Path 和 Files 了 NIO Channel，Buffer，Selector 高性能 IO 之 Reactor 模式 Java 并发 概述 JUC 包，毫无疑问的，得去学，哪怕平时编程根本不去用，但是得会，至少得知道有这个东西，至少得知道 aba，cas，aqs，unsafe，volatile，sync，常见的各种 lock，死锁，线程池参数和如何合理的去设置，必须明白自旋，阻塞，死锁和它如何去定位，oom 如何定位问题，cpu 过高如何定位等基本的操作。你可以没有生产调试经验，但不代表你可以不会 top，jps，jstack，jmap 这些可能会问的东西。 线程 线程创建 有三种使用线程的方法： 实现 Runnable 接口； 实现 Callable 接口； 继承 Thread 类。 链接：Java 并发的四种风味 线程状态 java.lang.Thread.State，里面的注释内容讲解得很清楚了 链接： Java 线程的 6 种状态及切换 (透彻讲解) Java 中一个线程只有六个状态。至于阻塞、可运行、挂起状态都是人们为了便于理解，自己加上去的 基础机制 sleep yield 静态方法 Thread.yield() ，切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。 守护线程 守护线程是指为其他线程服务的线程。在 JVM 中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。因此，JVM 退出时，不必关心守护线程是否已结束。 线程之间协作 join 在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。 wait() notify() notifyAll() 调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。 它们都属于 Object 的一部分，而不属于 Thread。 wait() 和 sleep() 的区别 wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法； wait() 会释放锁，sleep() 不会。 当使用调用 wait 时，虽然当前的线程还在 schronized 同步块中， 但是也会让出锁，要不然，notify 永远拿不到锁，永远得不到执行。 同样当使用完 notify 后，是不会立即释放锁的，必须使你当前线程走完 schronized 的代码，也就是说只有当前线程走完 schronized 代码块之后，wait 才会被执行。 可以看下这个：13 案例分析：多线程锁的优化.md (lianglianglee.com) 里面的 synchronied 小节 await() signal() signalAll() java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。 相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。 ReentrantLock 就用了 Condition 类。 他们释放锁吗？这里其实没这个说法，想想是不是这样~ LockSupport.park（ReentrantLock） 白话讲懂 wait notify 和 park unpark 的使用示例和区别_pengweismile 的专栏-CSDN 博客 面试 LockSupport.park() 会释放锁资源吗？ 中断线程 InterruptedException 何时抛出？ java.util.concurrent.ThreadPoolExecutor#shutdown 看看 interruptWorkers，interruptIdleWorkers interrupted 和 isInterrupted 区别 同步互斥 synchronized Java 对象 在 JVM 中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。 对象头：Java 对象头一般占有 2 个机器码（在 32 位虚拟机中，1 个机器码等于 4 字节，也就是 32bit，在 64 位虚拟机中，1 个机器码是 8 个字节，也就是 64bit），但是 如果对象是数组类型，则需要 3 个机器码，因为 JVM 虚拟机可以通过 Java 对象的元数据信息确定 Java 对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。 实例数据：存放类的属性数据信息，包括父类的属性信息。 对齐填充：由于虚拟机要求 对象起始地址必须是 8 字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。 对象头 Mark Work 指向类的指针 数组长度 Mark Work 锁状态 25bit 4bit 1bit 2bit 23bit 2bit 是否偏向锁 锁标志位 无锁 对象的 HashCode 分代年龄 0 01 偏向锁 线程 ID Epoch 分代年龄 1 01 轻量级锁 指向栈中锁记录的指针 00 重量级锁 指向重量级锁的指针 10 GC 标记 空 11 原理 死磕 Synchronized 底层实现 保证了原子性、可见性、有序性 可重入、不可中断 同步代码 所有的互斥，其实是获取 monitor 的所有权。 当我们进入一个人方法的时候，执行 monitorenter，就会获取当前对象的一个所有权，这个时候 monitor 进入数为 1，当前的这个线程就是这个 monitor 的 owner。 如果你已经是这个 monitor 的 owner 了，你再次进入，就会把进入数+1. 同理，当他执行完 monitorexit，对应的进入数就-1，直到为 0，才可以被其他线程持有。 同步方法 ACC_SYNCHRONIZED 标志位 同步方法的时候，一旦执行到这个方法，就会先判断是否有标志位，然后，ACC_SYNCHRONIZED 会去隐式调用刚才的两个指令：monitorenter 和 monitorexit。 所以归根究底，还是 monitor 对象的争夺。 Monitor 对象 Monitor 其实是一种同步工具，也可以说是一种同步机制，它通常被描述为一个对象。 主要特点： 对象的所有方法都被“互斥”的执行 通常提供 singal 机制 “ Java 对象是天生的 Monitor。” 关于Monitor对象在sychronized实现中的应用_super_x_man的博客-CSDN博客_monitor撖寡情 用户态和内核态的转换 过程是很复杂的，也涉及很多值的传递；synchronized 在 1.6 之前之所以说重量级，有部分原因在这，大量的系统资源消耗。 偏向锁与 hashcode 能共存吗 偏向锁与 hashcode 能共存吗？_Saintyyu 的博客-CSDN 博客 锁优化 这里的锁优化主要是指 JVM 对 synchronized 的优化。 自旋锁、锁消除、锁粗化 偏向锁、轻量级锁、重量级锁 彻底搞懂 synchronized(从偏向锁到重量级锁) 锁 优点 缺点 适用场景 偏向锁 加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。 如果线程间存在锁竞争，会带来额外的锁撤销的消耗。 适用于只有一个线程访问同步块场景。 轻量级锁 竞争的线程不会阻塞，提高了程序的响应速度。 如果始终得不到锁竞争的线程使用自旋会消耗 CPU。 追求响应时间。同步块执行速度非常快。 重量级锁 线程竞争不使用自旋，不会消耗 CPU。 线程阻塞，响应时间缓慢。 追求吞吐量。同步块执行速度较长。 volatile 可见性 重排序（编译器重排，处理器重排） happen-before 原则：深入理解 happens-before 规则 内存模型 对 volatile 的进一步补充，jvm 的内存模型。 并发三大特性 原子性，可见性，有序性 现代计算机内存模型 处理器与内存的速度矛盾，加入了一层读写速度尽可能接近处理器运算速度的 高速缓存（Cache），但它引入了一个新的问题：缓存一致性（CacheCoherence）。 在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（MainMemory）。 JMM Java 内存模型 (JavaMemoryModel) 描述了 Java 程序中各种变量（线程共享变量）的访问规则，以及在 JVM 中将变量，存储到内存和从内存中读取变量这样的底层细节。 JMM 有以下规定： 所有的共享变量都存储于主内存，这里所说的变量指的是实例变量和类变量，不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。 每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。 线程对变量的所有的操作 (读，取) 都必须在工作内存中完成，而不能直接读写主内存中的变量。 不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。 正是因为这样的机制，才导致了可见性问题的存在 主要有三种实现可见性的方式： volatile 每个线程操作数据的时候会把数据从主内存读取到自己的工作内存，如果他操作了数据并且写会了，他其他已经读取的线程的变量副本就会失效了，需要都数据进行操作又要再次去主内存中读取了。 volatile 保证不同线程对共享变量操作的可见性，也就是说一个线程修改了 volatile 修饰的变量，当修改写回主内存时，另外一个线程立即看到最新的值。 synchronized 某一个线程进入 synchronized 代码块前后，线程会获得锁，清空工作内存，从主内存拷贝共享变量最新的值到工作内存成为副本，执行代码，将修改后的副本的值刷新回主内存中，线程释放锁。 final 被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。 缓存一致性协议 别看加一个 volatile 关键字很简单，但实际上他在背后含辛茹苦默默付出了不少，了解下计算机层面的缓存一致性协议。 当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，那同步回到主内存时以谁的缓存数据为准呢？ 为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有 MSI、MESI（IllinoisProtocol）、MOSI、Synapse、Firefly 及 DragonProtocol 等。 MESI Intel 的 MESI 嗅探 重排序 为了提高性能，编译器和处理器常常会对既定的代码执行顺序进行指令重排序。 一般重排序可以分为如下三种： 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序; 指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序; 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。 as-if-serial 不管怎么重排序，单线程下的执行结果不能被改变。 编译器、runtime 和处理器都必须遵守 as-if-serial 语义。 Volatile 是怎么保证不会被执行重排序? 内存屏障 为了实现 volatile 的内存语义，JMM 会限制特定类型的编译器和处理器重排序，JMM 会针对编译器制定 volatile 重排序规则表： 需要注意的是：volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。 写 读 happens-before 上面提过的重排序原则，为了提高处理速度，JVM 会对代码进行编译优化，也就是指令重排序优化，并发编程下指令重排序会带来一些安全隐患：如指令重排序导致的多个线程操作之间的不可见性。 如果让程序员再去了解这些底层的实现以及具体规则，那么程序员的负担就太重了，严重影响了并发编程的效率。 从 JDK5 开始，提出了happens-before的概念 无法保证原子性 说了这么多，但 Volatile 是没办法保证原子性的，一定要保证原子性，得使用其他方法（比如原子类 AtomicInteger，加锁）。 常见应用：单例，用双重检查+synchronized+volatile 可能好奇为啥要双重检查？如果不用 Volatile 会怎么样？ 这个就得了解下创建对象的几个步骤，可能二三步会重排 分配内存空间。 调用构造器，初始化实例。 返回地址给引用 补充一些 对任意单个 volatile 变量的读/写具有原子性，但类似于 volatile++这种复合操作不具有原子性 内存间交互操作 Java 内存模型定义了 8 种操作来完成主内存和工作内存的变量访问： lock，unlock，read，load，use，assign，stroe，write 一些底层实现 内存屏障是什么？如何工作的？如何实现？在哪个层面上实现？ MESI 协议，Store Buffere（存储缓存），Invalidate Queue（失效队列） 搜索关键词（CPU 和 volatile ） final 一个类的 final 字段会在初始化后插入一个 store 屏障，来确保 final 字段在构造函数初始化完成并可被使用时可见。 参考文章： 面试官想到，一个 Volatile，敖丙都能吹半小时 既生 synchronized，何生 volatile？！ 非原子操作！！！ 一文解决内存屏障 - 简书 (jianshu.com) x86 架构的内存屏障 内存屏障 | 并发编程网 – ifeve.com 全面理解 Java 内存模型 (JMM) 及 volatile 关键字 - CSDN 博客 乐观锁 Atomic 类 概念：原子变量，CAS 其他： AtomicStampedReference 它还维护了一个时间戳，解决 ABA 问题 AtomicXXXFieldUpdater 原子更新器 在 Java5 中，JDK 就开始提供原子类了，当然也包括原子的更新器——即后缀为 FieldUpdater 的类 已经有了原子类，为啥还额外提供一套原子更新器呢？ 简单的说有两个原因，以 int 变量为例，基于 AtomicIntegerFieldUpdater 实现的原子计数器，比单纯的直接用 AtomicInteger 包装 int 变量的花销要小，因为前者只需要一个全局的静态变量 AtomicIntegerFieldUpdater 即可包装 volatile 修饰的非静态共享变量，然后配合 CAS 就能实现原子更新，而这样做，使得后续同一个类的每个对象中只需要共享这个静态的原子更新器即可为对象计数器实现原子更新，而原子类是为同一个类的每个对象中都创建了一个计数器 + AtomicInteger 对象，这种开销显然就比较大了。 了解一下 LongAdder 与 Striped64 LongAdder 区别于 AtomicLong ，在高并发中有更好的性能体现 JDK 1.8 中新增的 LongAdder，通过把原值进行拆分，最后再以 sum 的方式，减少 CAS 操作冲突的概率，性能要比 AtomicLong 高出 10 倍左右。 链接 《吊打面试官》系列-乐观锁、悲观锁 妹妹问我：互斥锁、自旋锁、读写锁、悲观锁、乐观锁的应用场景 Java 并发问题--乐观锁与悲观锁以及乐观锁的一种实现方式-CAS ReentrantLock 应用场景 还有 ReadWriteLock，StampedLock，应用场景的选择？ 公平，非公平 阿里面试官：说一下公平锁和非公平锁的区别？_敖丙-CSDN 博客 核心就是 tryAcquire 时，公平锁多了一个 !hasQueuedPredecessors() 判断 比较 synchronized 1. 锁的实现 synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。 2. 性能 新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。 3. 等待可中断 当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。 ReentrantLock 可中断，而 synchronized 不行。 4. 公平锁 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。 synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。 5. 锁绑定多个条件 一个 ReentrantLock 可以同时绑定多个 Condition 对象。 伴生类 Condition 可以看看上面的中断线程，提供了 await() 和 singal() 的功能，可以用于线程间消息通信。 AQS AbstractQueuedSynchronizer 它维护了一个volatile int state（代表共享资源）和一个 FIFO 线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里 volatile 是核心关键词 AQS 框架借助于两个类： Unsafe（提供 CAS 操作，可以了解一下） objectFieldOffset compareAndSwap... LockSupport（提供 park/unpark 操作） AbstractFuture (一旦调用 get 就会阻塞) 与 Object 类的 wait/notify 机制相比，park/unpark 有两个优点： 以 thread 为操作对象更符合阻塞线程的直观定义 操作更精准，可以准确地唤醒某一个线程（notify 随机唤醒一个线程，notifyAll 唤醒所有等待的线程），增加了灵活性。 应用： CountDownLatch、CyclicBarrier 和 Semaphore ReentrantLock 等 参考链接 https://blog.51cto.com/14220760/2390586?source=dra https://www.jianshu.com/p/da9d051dcc3d 并发容器 下面的每一个对比，都是面试中的知识点，想要更加深入地理解，你需要阅读 JDK 的源码。 StringBuilder 对应着 StringBuffer。后者主要是通过 synchronized 关键字实现了线程的同步。值得注意的是，在单个方法区域里，这两者是没有区别的，JIT 的编译优化会去掉 synchronized 关键字的影响。 HashMap ConcurrentHashMap：ConcurrentHashMap 的话题很大，java8 中的 ConcurrentHashMap 实现已经抛弃了 java7 中分段锁的设计，而采用更为轻量级的 CAS 来协调并发，效率更佳。 了解 computeIfAbsent 等并发处理方法 ConcurrentHashMapV8 (netty 提供) LinkedList ArrayBlockingQueue： ArrayBlockingQueue 对默认是不公平锁，可以修改构造参数，将其改成公平阻塞队列，它在 concurrent 包里使用得非常频繁。 同时还有 LinkedBlockingQueue，ConcurrentLinkedQueue 等，要看看源码如何实现（offer，take 方法）！ ConcurrentLinkedQueue： 最典型的无锁队列实现，使用 CAS 来处理对数据的并发访问，这是无锁算法得以实现的基础。 CAS 指令不会引起上下文切换和线程调度，是非常轻量级的多线程同步机制。它还把入队、出队等对 head 和 tail 节点的一些原子操作，拆分出更细的步骤，进一步缩小了 CAS 控制的范围。 性能很高，但不是很常用。千万不要和阻塞队列 LinkedBlockingQueue（内部基于锁）搞混了。 阻塞队列归类： 不存储元素： SynchronousQueue：一个不存储元素的阻塞队列。 有界： ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。 LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。 无界： PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。 DelayQueue：一个使用优先级队列实现的无界阻塞队列。 LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。 LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。 ArrayList 对应着 CopyOnWriteArrayList。后者是写时复制的概念，适合读多写少的场景。 HashSet 对应着 CopyOnWriteArraySet。 了解： SkipList（跳表） ConcurrentSkipListMap（使用跳表实现 Map） 和使用哈希算法实现 Map 的另外一个不同之处是：哈希并不会保存元素的顺序，而跳表内所有的元素都是排序的。因此在对跳表进行遍历时，你会得到一个有序的结果。所以，如果你的应用需要有序性，那么跳表就是你不二的选择。 其他组件 ThreadLocal 隐患：ThreadLocal 有一个 value内存泄露 的隐患 FastThreadLocal： 既然 Java 中有了 ThreadLocal 类了，为什么 Netty 还自己创建了一个叫作 FastThreadLocal 的结构？ 底层的 InternalThreadLocalMap 对 cacheline 也做了相应的优化。（伪共享问题） WeakReference 和 ReferenceQueue 这里重点看 ReferenceQueue，引用相关请看下面的对象引用小节 Callable 和 Future（since1.5） 在并发编程中，我们经常用到非阻塞的模型，在之前的多线程的三种实现中，不管是继承 thread 类还是实现 runnable 接口，都无法保证获取到之前的执行结果。通过实现 Callback 接口，并用 Future 可以来接收多线程的执行结果。 Future 表示一个可能还没有完成的异步任务的结果，针对这个结果可以添加 Callback 以便在任务执行成功或失败后作出相应的操作。 Guava——AbstractFuture ForkJoin CompletableFuture GC 停顿点 安全点（Safepoint） 撤销偏向锁（在一个安全点停止拥有锁的线程，具体看流程） Q&A 什么是上下文切换？ 并发与并行的区别？ 几个问题 Bounded-Buffer 问题： 生产者消费者问题（Producer-consumer problem），也称有限缓冲问题（Bounded-buffer problem），是一个多线程同步问题的经典案例。原文 并发中的伪共享问题（false sharing）： CPU 缓存是以缓存行（cache line）为单位存储的。缓存行通常是 64 字节，并且它有效地引用主内存中的一块地址。并发的修改在一个缓存行中的多个独立变量，看起来是并发执行的，但实际在 CPU 处理的时候，是串行执行的，并发的性能大打折扣。 Java 中通过填充缓存行，sun.misc.Contended 注解来解决伪共享问题。LMAX Disruptor Sequence采用了填充缓存行。 并不是所有的场景都需要解决伪共享问题，因为 CPU 缓存是有限的，填充会牺牲掉一部分缓存。 线程池 介绍：Executor 之 线程池及定时器 (novoland.github.io) 另外： 《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险 Executors 返回线程池对象的弊端如下： FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM。 CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。 三种队列 队列 简单解释 SynchrousQueue 不会保存提交任务，超出直接 corePoolSize 个任务，直接创建新的线程来执行任务，直到 (corePoolSize＋新建线程) > maximumPoolSize。 LinkedBlockingQueue 基于链表的先进先出，无界队列。超出直接 corePoolSize 个任务，则加入到该队列中，直到资源耗尽，所以 maximumPoolSize 不起作用。 ArrayBlockingQueue 基于数组的先进先出，创建时必须指定大小，超出直接 corePoolSize 个任务，则加入到该队列中，只能加该 queue 设置的大小，其余的任务则创建线程，直到 (corePoolSize＋新建线程) > maximumPoolSize。 上表收录自：线程池的三种缓存队列 解释看起来文邹邹的，要不直接上代码：execute： public void execute(Runnable command) { if (command == null) throw new NullPointerException(); int c = ctl.get(); if (workerCountOf(c) 注意： ？SynchronousQueue误区：很多人把其认为其没有容量，不存储元素，这是错的。 好好了解这个结构，并看看其核心算法transfer。后来实在看不懂...，先记住这句话吧：生产者线程对其的插入操作 put 必须等待消费者的移除操作 take，反过来也一样。你不能调用 peek() 方法来看队列中是否有数据元素，因为数据元素只有当你试着取走的时候才可能存在，不取走而只想偷窥一下是不行的，当然遍历这个队列的操作也是不允许的。 链接： SynchronousQueue应用 - hongdada - 博客园 (cnblogs.com) 四种拒绝策略 AbortPolicy // 默认，队列满了丢任务抛出异常 DiscardPolicy // 队列满了丢任务不异常 DiscardOldestPolicy // 将最早进入队列的任务删，之后再尝试加入队列 CallerRunsPolicy // 如果添加到线程池失败，那么主线程会自己去执行该任务 原理 ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 原理 ScheduledThreadPoolExecutor 原理 线程池运行状态 这里有空要详细看看 shutdown(), shutdownNow()和awaitTermination() 注意，一旦线程池有任务开始跑，就算任务都跑完了，也会等待keepAliveTime时候后才会停止。一般测试小 demo 的时候发现程序一直得不到结束，原因基本是这个。 public static void main(String[] args) throws InterruptedException { ExecutorService executor = Executors.newCachedThreadPool(); executor.execute(() -> System.err.println(\"executor\")); // TimeUnit.SECONDS.sleep(5L); // executor.shutdown(); System.err.println(\"finish\"); // 两个打印都输出后，程序还要等待 60s 才会结束！！ } 源码分析： java.util.concurrent.ThreadPoolExecutor#runWorker这里会一直调用task = getTask()，getTask里会调用workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)或者workQueue.take()，因此没任务后它也会阻塞keepAliveTime时间 或者 永久阻塞。 分析一下shutdown()，它里面调用了interruptIdleWorkers()，它会打断上述的wait keepAliveTime的状态，抛出中断异常，而getTask()会捕获这个异常，从而打破阻塞状态。 线程池异常处理 java.util.concurrent.ThreadPoolExecutor#runWorker 使用 execute 方法提交的任务一般没问题 有需要可以重写 afterExecute 但注意 sumbit 这种情况，FutureTask 自己封装处理了异常，不通过 Future 是获取不到的，看看这篇文章： 记一次线程池引发的故障 排查下来是三歪的锅 这篇文章其实是有点问题的，他最后的 setUncaughtExceptionHandler 是获取不到 sumbit 的异常的，但还是可以通过这篇文章了解下整体的脉络。 协程 协程，英文 Coroutines，是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。 Java 语言并没有对协程的原生支持，但是某些开源框架模拟出了协程的功能，有兴趣的小伙伴可以看一看 Kilim 框架的源码 Java 虚拟机 前言 JVM 很难，网上错误的观点很多 垃圾回收算法，垃圾收集器，jvm 内存模型，每个区域用途，各种 oom 的种类，jvm 调优经验，没有你也要做过，自己去设置启动参数，知道常见参数的含义，类加载过程，双亲委派，什么时候 young gc，full gc，各种情况进入老年代的方式，你知道的越多越好，因为吹起来就越自信，举个例子，逃逸分析是什么？markword 里面有什么？ 不错的系列文章 JVM 核心技术 32 讲（完） (lianglianglee.com) 内存管理 内存划分 JVM中的五大内存区域划分详解及快速扫盲 注意 1.7 和 1.8之后的区别 1.7之前： 1.8之后： 注意：Metaspace 使用的是本地内存（native memory），所以它的最大内存可以达到机器内存的极限 -XX:MetaspaceSize 并不代表初始的 Metaspace 大小。大致意思就是当 MetaspaceSize 接近一个指定水位（high-water mark）的时候，会引发垃圾回收。 G1调优实践日记--被误解的MetaspaceSize_葵续浅笑的博客-CSDN博客 堆是线程共享的内存区域？ 不完全正确。因为 HotSpot 中，TLAB 是堆内存的一部分，他在读取上确实是线程共享的，但是在内存分配上，是线程独享的。链接 字符串常量池在那个区域中？ 答案：这个要看 JDK 版本。 在 JDK 1.8 之前，是没有元空间这个概念的，当时的方法区是放在一个叫作永久代的空间中。 而在 JDK 1.7 之前，字符串常量池也放在这个叫作永久带的空间中。但在 JDK 1.7 版本，已经将字符串常量池从永久带移动到了堆上。 所以，从 1.7 版本开始，字符串常量池就一直存在于堆上。对于 JDK1.8 时，HostSpot VM 对 JVM 模型进行了改造，将元数据放到本地内存，将常量池和静态变量放到了Java堆里。 直接内存和本地内存 直接内存，指的是使用了 Java 的直接内存 API，进行操作的内存。这部分内存可以受到 JVM 的管控，比如 ByteBuffer 类所申请的内存，就可以使用具体的参数进行控制。 需要注意的是直接内存和本地内存不是一个概念。 直接内存比较专一，有具体的 API（这里指的是ByteBuffer），也可以使用 -XX:MaxDirectMemorySize 参数控制它的大小； 本地内存是一个统称，比如使用 native 函数操作的内存就是本地内存，本地内存的使用 JVM 是限制不住的，使用的时候一定要小心。 内存模型 这个关系到线程，线程安全，具体看 Java并发-同步互斥-内存模型 （不要和内存管理的内存划分搞混） 内存分析 一个Java对象到底占多少个字节？ 可以用 ClassLayout.parseInstance(new Integer(5)).toPrintable() 工具输出，注意在不同位数的JVM和是否开启指针压缩的场景下，输出会有不同。 字节码 局部变量表中的 Slot 为什么 JVM 局部变量表的一个 slot 至少要能容纳一个 int 类型的变量？ 为什么 Java 虚拟机 JVM 要把 byte 和 short 的运算都转为 int ？ Class 类的文件结构 方法表，属性表... 类加载 ClassLoader Bootstrap ClassLoader、 Extention ClassLoader、AppClassLoader Classloader 将数据加载到内存中经过的步骤： 加载：加载类的二进制数据 链接 验证 确保加载的类的正确性。准备 类中的静态变量分配内存，并且其初始化为默认值。解析 把类中的符号引用变为直接引用。 初始化 为类中的类中的静态变量赋值（正确的初始值） 参考：ClassLoader 那事儿 问题： Q：同一个 Class 的static 字段，被不同的 ClassLoader 加载，会有产生几份？ A：会是两份，也就是 JVM 里有两份内存（某次面试时问到的，但自己没试过） 指令集 方法调用 JVM提供了5种方法调用指令，其作用列举如下： invokestatic：该指令用于调用静态方法，即使用 static 关键字修饰的方法； invokespecial：该指令用于三种场景：调用实例构造方法，调用私有方法（即private关键字修饰的方法）和父类方法（即super关键字调用的方法）； invokeinterface：该指令用于调用接口方法，在运行时再确定一个实现此接口的对象； invokevirtual：该指令用于调用虚方法（就是除了上述三种情况之外的方法）； invokedynamic：在运行时动态解析出调用点限定符所引用的方法之后，调用该方法；在JDK1.7中推出，主要用于支持JVM上的动态脚本语言（如Groovy，Jython等）。 通过实例一行一行分析JVM的invokespecial和invokevirtual指令 | wxweven 梦想之家，这篇文章一定要认真读一下！！ Java中MethodHandle的使用问题？ - 知乎 (zhihu.com) 编译与优化 HotSpot 虚拟机 JIT 解释执行 逐条将字节码翻译成机器码并执行 即时编译（Just-in-time ，JIT） 将一个方法中包含的所有字节码编译成机器码后再执行。 逃逸分析 JVM 优化之逃逸分析与分配消除 面试问我 Java 逃逸分析，瞬间被秒杀了。。 GC 垃圾收集事件 Minor GC（小型 GC） 简单定义：Minor GC 清理的是年轻代，又或者说 Minor GC 就是“年轻代 GC”（Young GC，简称 YGC）。 关于 Minor GC 事件，我们需要了解一些相关的内容： 当 JVM 无法为新对象分配内存空间时就会触发 Minor GC（ 一般就是 Eden 区用满了）。如果对象的分配速率很快，那么 Minor GC 的次数也就会很多，频率也就会很快。 Minor GC 事件不处理老年代，所以会把所有从老年代指向年轻代的引用都当做 GC Root。从年轻代指向老年代的引用则在标记阶段被忽略。 与我们一般的认知相反，Minor GC 每次都会引起 STW 停顿（stop-the-world），挂起所有的应用线程。对大部分应用程序来说，Minor GC 的暂停时间可以忽略不计，因为 Eden 区里面的对象大部分都是垃圾，也不怎么复制到存活区/老年代。但如果不符合这种情况，那么很多新创建的对象就不能被 GC 清理，Minor GC 的停顿时间就会增大，就会产生比较明显的 GC 性能影响。 Major GC vs. Full GC 值得一提的是，这几个术语都没有正式的定义--无论是在 JVM 规范中还是在 GC 论文中。 我们知道，除了 Minor GC 外，另外两种 GC 事件则是： Major GC（大型 GC）：清理老年代空间（Old Space）的 GC 事件。 Full GC（完全 GC）：清理整个堆内存空间的 GC 事件，包括年轻代空间和老年代空间。 其实 Major GC 和 Full GC 有时候并不能很好地区分。更复杂的情况是，很多 Major GC 是由 Minor GC 触发的，所以很多情况下这两者是不可分离的。 另外，像 G1 这种垃圾收集算法，是每次找一小部分区域来进行清理，这部分区域中可能有一部分是年轻代，另一部分区域属于老年代。 所以我们不要太纠结具体是叫 Major GC 呢还是叫 Full GC，它们一般都会造成单次较长时间的 STW 暂停。所以我们需要关注的是：某次 GC 事件，是暂停了所有线程、进而对系统造成了性能影响呢，还是与其他业务线程并发执行、暂停时间几乎可以忽略不计。 垃圾收集器 Serial、Serial Old ParNew Parallel Scavenge、Parallel Old CMS CMS 也可称为“并发标记清除垃圾收集器”。其设计目标是避免在老年代 GC 时出现长时间的卡顿。默认情况下，CMS 使用的并发线程数等于 CPU 内核数的 1/4。 CMS 垃圾回收器详解 过程 阶段 1：Initial Mark（初始标记） 阶段 2：Concurrent Mark（并发标记） 阶段 3：Concurrent Preclean（并发预清理） 阶段 4：Concurrent Abortable Preclean（可取消的并发预清理） 阶段 5：Final Remark（最终标记） 阶段 6：Concurrent Sweep（并发清除） 阶段 7：Concurrent Reset（并发重置） 结合下面两篇文章看： 14 常见的 GC 算法（ParallelCMSG1）.md (lianglianglee.com) 19 GC 日志解读与分析（实例分析中篇）.md (lianglianglee.com) CMS 之 promotion failed & concurrent mode failure 然后 CMS 的并发周期就会被一次 Full GC 代替，退回到 Serial Old 收集器进行回收，这是一次长 Stop The World 关于 CMS 垃圾回收失败是不是进行 FULL GC 问题的记录 G1 概要 实现高吞吐量的同时，尽可能的满足垃圾收集暂停时间的要求。 它仍然属于分代收集器，但新生代，老年代的物理空间划分取消了，传统上的堆内存结构被抛弃。 G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有 cms 内存碎片问题的存在了。 不要设置年轻代的大小，通过-Xmn显式设置年轻代的大小，会干扰G1收集器的默认行为 开发人员仅仅需要声明以下参数即可： -XX:+UseG1GC -Xmx32g -XX:MaxGCPauseMillis=200 其中-XX:+UseG1GC为开启G1垃圾收集器，-Xmx32g设计堆内存的最大内存为32G，-XX:MaxGCPauseMillis=200设置GC的最大暂停时间为200ms。如果我们需要调优，在内存大小一定的情况下，我们只需要修改最大暂停时间即可。 -XX:InitiatingHeapOccupancyPercent 整个堆使用到达这个阈值时，触发一次 mixed gc，默认是45% 并发标记过程 阶段 1：Initial Mark（初始标记） 阶段 2：Root Region Scan（Root 区扫描） 阶段 3：Concurrent Mark（并发标记） 阶段 4：Remark（再次标记） 阶段 5：Cleanup（清理） Full GC G1中的 Full GC 也而是单线程串行的，而且是全暂停，使用的是标记-整理算法，代价非常高。G1的初衷就是要避免 Full GC 的出现。 CMS 收集器和 G1 收集器 他们的优缺点对比 参考： 可能是最全面的 Java G1学习笔记_xiaoye的博客-CSDN博客 转：深入理解Java G1垃圾收集器 - sidesky - 博客园 (cnblogs.com) G1垃圾回收器详解 - 简书 (jianshu.com) ZGC Shenandoah Epsilon：实验性的 GC，供性能分析使用 他们什么阶段会stop the world？ 看《深入理解 Java 虚拟机》3.5 节 经典垃圾收集器，这里每种收集器的执行图讲解了哪个阶段会 STW JVM 默认启用的收集器是哪些？ 看《深入理解 Java 虚拟机》3.7.4 节 垃圾收集器参数总结，这个讲解了 client 和 server 模式下的默认值，以及开启其他收集器的参数 参考： Java虚拟机垃圾回收——7种垃圾收集器 垃圾收集器_晏霖/胖虎的博客 GC 性能优化 4. GC 算法(实现篇) - GC 参考手册 7. GC 调优(实战篇) - GC参考手册 Java 方法 finalize() 该方法会在垃圾收集器交换回收对象之前被调用。如果在finalize()方法中，又使得该对象被程序引用(俗称复活了)，则该对象就变成了可触及的对象，暂时不会被垃圾收集了。每个对象只能调用一次finalize( )方法，所以每个对象也只可能 \"复活 \"一次。 System.gc() 建议执行垃圾收集 GC 日志 日志解读 注意 Minor GC 和 Full GC 时的日志 17 GC 日志解读与分析（基础配置）.md (lianglianglee.com) 18 GC 日志解读与分析（实例分析上篇）.md (lianglianglee.com) 19 GC 日志解读与分析（实例分析中篇）.md (lianglianglee.com) Java9 后的日志格式变化 使用：-XX:+PrintCommandLineFlags -Xlog:gc*=debug:./gc.log:level,time,tags Disruptive Changes to GC Logging in Java 9 - DZone Java 分析工具 Universal JVM GC analyzer - Java Garbage collection log analysis made easy (gceasy.io) 调优 GC日志中 real 时间比 user + sys 时间长该如何处理？ 可能导致 FullGC 的原因有以下几种。 老年代空间不足。 永生代或者元数据空间不足。 程序执行了 System.gc() //建议 jvm 执行 fullgc，并不一定会执行。 CMS GC 时出现 promotion failed 和 concurrent mode failure YoungGC 时晋升老年代的内存平均值大于老年代剩余空间（执行 minor gc 的时候进行的一系列检查） 有连续的大对象需要分配 执行了 jmap -histo:live pid 命令 //这个会立即触发 fullgc 出现 Full GC 一般是不正常 参数 Young Tenured JVM options Incremental(增量GC) Incremental -Xincgc Serial Serial -XX:+UseSerialGC Parallel Scavenge Serial -XX:+UseParallelGC -XX:-UseParallelOldGC Parallel New Serial N/A Serial Parallel Old N/A Parallel Scavenge Parallel Old -XX:+UseParallelGC -XX:+UseParallelOldGC Parallel New Parallel Old N/A Serial CMS -XX:-UseParNewGC -XX:+UseConcMarkSweepGC Parallel Scavenge CMS N/A Parallel New CMS -XX:+UseParNewGC -XX:+UseConcMarkSweepGC G1 -XX:+UseG1GC 主要使用的是上表中黑体字表示的这四种组合。其余的要么是被废弃(deprecated)，要么是不支持或者是不太适用于生产环境。 eg. Jdk8： -XX:+PrintCommandLineFlags -Xms52m -Xmx52m -Xloggc:gc.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps Serial：-XX:+UseSerialGC Parallel：-XX:+UseParallelGC -XX:+UseParallelOldGC CMS：-XX:+UseConcMarkSweepGC G1：-XX:+UseG1GC Jdk9+： -XX:+PrintCommandLineFlags -Xms52m -Xmx52m -Xlog:gc*=debug:gc.log:level,time,tags 性能调优 JVM参数 注意 JDK 版本，不一定都通用 堆区： -Xms and -Xmx (or: -XX:InitialHeapSize and -XX:MaxHeapSize，实际上是两者的缩写) -Xmn（or: -XX:NewSize and -XX:MaxnewSize，-Xmn 是对两者的同时配置，JDK4生效） -Xss，设置每个线程的堆栈大小，JDK5.0以后每个线程堆栈大小为1M -XX:NewRatio -XX:SurvivorRatio -XX:MetaspaceSize -XX:MaxMetaspaceSize，JDK8后替换永久代 -XX:+UseCompressedOops -XX:+UseCompressedClassPointers，目的是为了在 64bit 机器上使用 32bit 的原始对象指针 非堆区： -XX:PermSize -XX:MaxPermSize JVM调优总结 -Xms -Xmx -Xmn -Xss 工具 jps、jstat、jinfo、jstack、jmap、jhat jstat -gcutil Java性能调优工具 JVisualVM 使用 VisualVM 进行性能分析及调优 jmc JDK Mission Control MAT Eclipse Memory Analyzer Atthas Arthas 是基于 Greys 进行二次开发的全新在线诊断工具 Arthas 使用指南 快速入门 — Arthas 3.5.5 文档 (aliyun.com) FastThread FastThread 是一款线程转储(Thread Dump)分析工具，官网地址为：http://fastthread.io/ 。 这款工具由 tier1app 公司 开发和支持，这家公司现在主要提供 3 款 JVM 分析工具，除了 FastThread 还有： GCEasy，访问地址：https://gceasy.io/，详情请参考前面的文章 [《GC 日志解读与分析（番外篇可视化工具）》]。 HeapHero，官网地址：https://heaphero.io/，顾名思义，这是一款 Heap Dump 分析工具。 Q&A 计算机内存模型 与 Java 内存模型 GC static 会被 GC 回收吗？static 的在内存中的存放位置？ 永久代不够会触发 Full GC 吗 锁 synchronized 或其他锁的产生的阻塞，其和 wait 的区别？ 当一个线程的时间片耗尽之后，其 synchronized 的代码会发生原子性问题吗？ 线程 1 在执行monitorenter指令的时候，会对 Monitor 进行加锁，加锁后其他线程无法获得锁，除非线程 1 主动解锁。即使在执行过程中，由于某种原因，比如 CPU 时间片用完，线程 1 放弃了 CPU，但是，他并没有进行解锁。而由于synchronized的锁是可重入的，下一个时间片还是只能被他自己获取到，还是会继续执行代码。直到所有代码执行完。这就保证了原子性。 JDK1.6 后对锁进行的优化，轻量级锁，偏向锁，锁消除，适应性自旋锁，锁粗化 (自旋锁在 1.4 就有，只不过默认的是关闭的，jdk1.6 是默认开启的) 国内 Java 面试总是问 StringBuffer，StringBuilder 区别是啥？档次为什么这么低？ 反射缺点？ 1.由于是本地方法调用，让 JVM 无法优化 (还有 JIT？) 2.反射方法调用还有验证过程和参数问题，参数需要装箱拆箱、需要组装成 Object[] 形式、异常的包装等等问题 Java 新特性 Java 7 JDK7 动态方法调用 java.lang.invoke 包 主要包含了 CallSite、MethodHandle、MethodType 等类 MethodHandle 看 MethodHandle 新增了 invokedynamic 指令 ForkJoin Java 8 时间类：Instant 和 LocalDate，LocalTime，LocalDateTime 如果是 JDK8 的应用，可以使用 Instant 代替 Date，LocalDateTime 代替 Calendar，DateTimeFormatter 代替 Simpledateformatter，官方给出的解释：simple beautiful strong immutable thread-safe。 附：测试代码请看 metis: com.ariescat.metis.base.time.LocalDateTimeTest stream parallelStream 函数式编程 Java 函数优雅之道 Optional 类 Supplier 接口和 Consumer 接口 （JDK8 以下可用 guava 替代） Alyx 的 FileLoader 优化用到了 Supplier CompletableFuture 强大的函数式异步编程辅助类 可以比较一下 Google Guava，其也提供了通用的扩展 Future：ListenableFuture、SettableFuture 以及辅助类 Futures 等，方便异步编程。 windforce AbstractChatChannel Java CompletableFuture 详解 · 鸟窝 (colobu.com) [译]20 个使用 Java CompletableFuture 的例子 · 鸟窝 (colobu.com) 语法糖 Lambda 实现原理 非捕获式 (non-capturing lambda) 和捕获式 (capturing lambda) Java 中的 lambda 每次执行都会创建一个新对象吗？ 测试代码：study-metis: com.ariescat.metis.base.jdk8.lambda.LambdaTest2，参考链接 ::（双冒号）的实现原理 List al = Arrays.asList(\"a\", \"b\", \"c\", \"d\"); al.forEach(AcceptMethod::printValur); //下面的方法和上面等价的 Consumer methodParam = AcceptMethod::printValur; //方法参数 al.forEach(x -> methodParam.accept(x));//方法执行 accept JVM 元空间（Metaspace） Java 9 Reactive Streams Flow API HTTP / 2 Client 统一的JVM日志系统 Java 11 直接运行源代码 ZGC 垃圾收集器 Java 12 Shenandoah 垃圾收集器 Q&A JDK 1.8 下的 java.lang.Class 对象和 static 成员变量在堆还是方法区？ Copyright © Ariescat all right reserved，powered by Gitbook最后修改时间： 2022-03-08 13:30 "},"Awesome/Web.html":{"url":"Awesome/Web.html","title":"框架","keywords":"","body":"《Web》 框架 基础工具库 Apache commons Commons IO FileAlterationMonitor和FileAlterationObserver（Alyx 曾发现这里每隔 10 秒会涨 10M 内存，待研究） Commons Lang3 等 Google Guava Google Guava 是 Google 公司内部 Java 开发工具库的开源版本。Google 内部的很多 Java 项目都在使用它。它提供了一些 JDK 没有提供的功能，以及对 JDK 已有功能的增强功能。 主要包括了： 集合（Collections） 缓存（Caching） 原生类型支持（Primitives Support） 并发库（Concurrency Libraries） 通用注解（Common Annotation） 字符串处理（Strings Processing） 数学计算（Math） I/O 事件 总线（EventBus） 一些有用的小工具： BloomFilter布隆过滤器的实现 源码分析：https://ifeve.com/google-guava Json 关于 Gson 的几个坑 Spring Spring 最好能抽空看看源码，最起码 bean 的生命周期，如何解决循环依赖，父子容器，还有 boot 的启动流程，事务实现原理，动态代理原理等，你知道越多越好。 Spring 源码浅析 IOC 依赖注入，控制反转 Spring IOC 容器源码分析_Javadoop 循环依赖及三级缓存 Spring 循环依赖及三级缓存 弄清楚： 三级缓存是分别是什么，分别是什么时候起作用？ 为何需要三级缓存，二级缓存不行吗？ Spring 对 groovy 的生成的 bean 为何解决不了循环依赖？ 这里主要是： bean 生成的时机是 postProcessBeforeInstantiation，没有走到 doCreateBean，而 addSingletonFactory 是在 doCreateBean 调用的 protected void addSingletonFactory(String beanName, ObjectFactory singletonFactory) { Assert.notNull(singletonFactory, \"Singleton factory must not be null\"); synchronized (this.singletonObjects) { if (!this.singletonObjects.containsKey(beanName)) { this.singletonFactories.put(beanName, singletonFactory); this.earlySingletonObjects.remove(beanName); this.registeredSingletons.add(beanName); } } } bean 是由 ScriptFactoryPostProcessor#scriptBeanFactory 生成的，这个 scriptBeanFactory 是一个全新的，然后 copyConfigurationFrom 了一次 parent 的属性 Spring AOP AOP 原理，ProxyFactory AOP 中 Pointcut，Advice 和 Advisor 三个概念 还有 Advised Advised 在 Spring 中创建了 AOP 代理之后，就能够使用 org.springframework.aop.framework.Advised 接口对它们进行管理。 任何 AOP 代理都能够被转型为这个接口，不论它实现了哪些其它接口 Advisor 类似使用 Aspect 的@Aspect 注解的类 Advice @Before、@After、@AfterReturning、@AfterThrowing、@Around Pointcut @Pointcut Spring tx 的解析过程 @Transactional 代理过程，用的什么代理，怎么代理 这里有一点需要注意的地方，由于 SpringAOP 的原因，@Transactional 注解只能用到 public 方法上，如果用到 private 方法上，将会被忽略，这也是面试经常问的考点之一。 Spring Cache 介绍 Spring Webflux （reactive web 框架，与前端 Flux 架构名字相同） 命令式编程 VS 响应式编程 Spring Data Spring Data JPA 简单查询--接口方法 - 如莲家园 - 博客园 JPA的查询语言—使用原生SQL_ChenAllen1025的专栏-CSDN博客 与其他构架的整合 企业大型互联网分布式架构 {Java 分布式架构 dubbo+springmvc+mybatis+ehcach+redis }-IT 未来-ITPUB 博客 手把手教你从最基本的 Java 工程搭建 SpringMVC+SpringDataJPA+Hibernate(含源码下载) - anxpp 的博客 - CSDN 博客 SpringBoot SpringBoot 自动配置机制 SpringBoot 启动过程 SpringBootStarter 依赖 简易教程 Spring Boot教程™ (yiibai.com) SpringCloud 核心子项目： Spring Cloud Netflix：核心组件，可以对多个 Netflix OSS 开源套件进行整合，包括以下几个组件： Eureka：服务治理组件，包含服务注册与发现 Hystrix：容错管理组件，实现了熔断器 Ribbon：客户端负载均衡的服务调用组件 Feign：基于 Ribbon 和 Hystrix 的声明式服务调用组件 Zuul：网关组件，提供智能路由、访问过滤等功能 Archaius：外部化配置组件 Spring Cloud Config：配置管理工具，实现应用配置的外部化存储，支持客户端配置信息刷新、加密/解密配置内容等。 Spring Cloud Bus：事件、消息总线，用于传播集群中的状态变化或事件，以及触发后续的处理 Spring Cloud Security：基于 spring security 的安全工具包，为我们的应用程序添加安全控制 Spring Cloud Consul：封装了 Consul 操作，Consul 是一个服务发现与配置工具（与 Eureka 作用类似），与 Docker 容器可以无缝集成 简易教程： Spring Cloud 微服务架构学习笔记与示例 - EdisonZhou - 博客园 (cnblogs.com) ASM 神器 spring-core 自带有 asm，org.ow2.asm 也是一个轻量级的 jar 还有 byte buddy 库，javassist 库 JAX-RS 全称：Java API for RESTful Web Services，是一套用 java 实现 REST 服务的规范，提供了一些标注将一个资源类，一个 POJOJava 类，封装为 Web 资源。 包括： @Path，标注资源类或方法的相对路径 @GET，@PUT，@POST，@DELETE，标注方法是用的 HTTP 请求的类型 @Produces，标注返回的 MIME 媒体类型 @Consumes，标注可接受请求的MIME 媒体类型 @PathParam，@QueryParam，@HeaderParam，@CookieParam，@MatrixParam，@FormParam，分别标注方法的参数来自于 HTTP 请求的不同位置，例如@PathParam 来自于 URL 的路径，@QueryParam 来自于 URL 的查询参数，@HeaderParam 来自于 HTTP 请求的头信息，@CookieParam 来自于 HTTP 请求的 Cookie Eureka的ApplicationResource有用到 缓存 Guava 的缓存 Guava Cache 说简单点就是一个支持LRU的 ConcurrentHashMap 简析 guava cache 线程安全设计哲学 - 简书 (jianshu.com) Caffeine 来自未来的缓存 Caffeine 是基于 JAVA 1.8 Version 的高性能缓存库。Caffeine 提供的内存缓存使用参考 Google guava 的 API。Caffeine 是基于 Google Guava Cache 设计经验上改进的成果。 日志 区分commons-logging，slf4j，log4j，logback Java日志，需要知道的几件事(commons-logging,log4j,slf4j,logback)_kobejayandy的专栏-CSDN博客 了解jcl-over-slf4j，jul-to-slf4j这些 jar 的作用 了解log4j和log4j2的区别，lmax disruptor应用场景 log4j log4j是如何拖慢你的系统的_veZunShao的专栏-CSDN博客 Flume 日志采集系统，一般用于日志聚合 ORM 库 hibernate 查询：HQL 查询，QBC 查询，SQL 查询 级联查询：一对一，一对多（多对一），多对多；懒加载，1+n 问题 其他： session.get(): 非懒加载方法 session.load(): 默认就是是懒加载 抓取策略（fetch）和 懒加载（lazy） mybatis mybatis 3.x源码深度解析与最佳实践（最完整原创） - zhjh256 - 博客园 (cnblogs.com) Netty 概述 Netty 的线程模型 通过Reactor 模型基于多路复用器接收并处理用户请求，内部实现了两个线程池，boss 线程池和 work 线程池，其中 boss 线程池的线程负责处理请求的 accept 事件，当接收到 accept 事件的请求时，把对应的 socket 封装到一个 NioSocketChannel 中，并交给 work 线程池，其中 work 线程池负责请求的 read 和 write 事件 NioEventLoop 设计原理 定时任务的原理 netty 对象池使用与回收 时间轮算法 HashedWheelTimer hashWheel 定时器和 Quartz 的区别：1）Quartz 将定时任务分为任务和触发器，而 hashWheel 只有任务的概念 2）Quartz 通过一个 TreeSet 对所有的触发器进行管理，而 hashWheel 通过一个 hash 轮来对所有的任务进行管理 3）Quartz 能够非常方便的删除定时任务，而 netty 的 hashWheel 暂时没有删除任务的接口（除非自己实现一个 hashWheel 定时器） 4）Quartz 有一个专门的调度线程对任务进行管理，任务执行有另外专门的线程池，而 hashWheel 用一个线程实现对任务的管理和任务的执行。 5）Quartz 能够通过序列化，将定时任务保存在数据库，而 hashWheel 不能 总的来说，Quartz 的功能相对强大，而 hashWheel 相对要轻量级一点。 附： 个人认为 netty 对用户来说是异步，但是实际底层 IO 是 IO 多路复用模型，本质上还是一种同步非阻塞（是的，个人认为 IO 多路复用模型还是同步非阻塞，并且真正的 IO 操作都将阻塞应用线程），他只是多了一个 Selector（需要底层操作系统支持），如此一个线程就可以控制大量的通信（相比传统 IO，不管他是不是非阻塞）。 另看 IO#IO 概念，这里也收录了一些理解 面试 阿里大牛总结的Netty最全常见面试题，面试再也不怕被问Netty了 - 知乎 (zhihu.com) Disruptor Disruptor 是一个无锁、有界的队列框架，它的性能非常高。 背景 锁的缺点 - Disruptor 入门 并发中的伪共享问题 代码的并发执行大约是两件事：互斥和变化的可见性。 互斥是关于管理某些资源的竞争更新。 变化的可见性是关于控制何时使这些更改对其他线程可见。 设计上的优势 内部数据存储使用环形缓冲（Ring Buffer），这样分配支持了CPU 缓存位置预测，GC 的压力更小 尽量使用无锁设计，合理使用 CAS 优化数据结构（填充缓存行），解决伪共享问题 合理位运算（如 2 次方幂求模），合理使用 Unsafe 策略 WaitStrategy可以选择YieldingWaitStrategy（无锁） 参考博客 解读 Disruptor 系列，这个系列挺好的，他每篇文章后面都有份参考资料，也可以认真看看 扩展 AtomicXXX.lazySet 这个方法的作用（Sequence#set 相当于 AtomicLong#lazySet） Unsafe 类的作用？为什么要用这个类？除了 JDK，在 Netty、Spring、Kafka、Storm 等非常多的流行开源项目中都使用了 Unsafe 原子类型集合库 避免开销很大的装箱/拆箱操作，节省了原始类型装箱消耗的内存 Koloboke 生成高性能的 JAVA 基本类型 map/set Eclipse Collections Fastutil 时间库 joda 对时间的操作 Quartz 定时任务 RxJava ➮详细 \" a library for composing asynchronous and event-based programs using observable sequences for the Java VM \" （一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库） 工具 构建工具 Maven Gradle 十分钟理解 Gradle - Bonker - 博客园 慕课实战：Gradle3.0 自动化项目构建技术精讲+实战 版本管理工具 Git 持续集成部署 Jenkins 单元测试 玩转单元测试之 DBUnit - WadeXu - 博客园 逆向工程 Java 代码生成利器之 rapid-generate 应用 中间件 Zookeeper 场景 ZooKeeper来做：统一配置管理、统一命名服务、分布式锁、集群管理。 使用分布式系统就无法避免对节点管理的问题（需要实时感知节点的状态、对节点进行统一管理等等），而由于这些问题处理起来可能相对麻烦和提高了系统的复杂性，ZooKeeper 作为一个能够通用解决这些问题的中间件就应运而生了。 原理 Zookeeper 的功能以及工作原理 Leader 选举-选举过程介绍比较清晰 ZAB 协议理解 消息队列 主要使用场景： 异步、削峰、解耦 带来问题： 系统复杂性 消息重复消费、消息丢失、消息的顺序消费等等 数据一致性 其他服务失败导致数据不一致？需要分布式事务？ 可用性 MQ挂了咋办？ 主流： Kafka 和 RocketMQ Kafka 场景 想要保证消息（数据）是有序的，怎么做？ Kafka会将数据写到 partition，单个 partition 的写入是有顺序的。如果要保证全局有序，那只能写入一个 partition 中。如果要消费也有序，消费者也只能有一个。 Kafka 性能优化： 零拷贝网络和磁盘 优秀的网络模型，基于 Java NIO 高效的文件数据结构设计 Parition 并行和可扩展 数据批量传输 数据压缩 顺序读写磁盘 无锁轻量级 offset 参考 Kafka性能篇：为何Kafka这么\"快\"？ RocketMQ TODO RabbitMQ 了解其 Exchange (交换器)，常用的有四种：direct、topic、fanout、headers MySQL sharding-jdbc 支持数据分片，分布式事务，数据库治理 连接池 目的：解决建立数据库连接耗费资源和时间很多的问题，提高性能。 自定义数据库连接池要实现 javax.sql.DataSource 接口，一般都叫数据源。 常用的数据源： DBCP：Apache推出的Database Connection Pool C3P0：开源的 JDBC 连接池 其他 apache DBUtils DBUtils简化了JDBC的开发步骤，使得我们可以用更少量的代码实现连接数据库的功能。 TDDL、cobar 等 搜索引擎 Elasticsearch Elasticsearch 基础教程 - CSDN 博客 倒排索引 和 传统关系型数据库 的对比 Relational DB Databases Tables Rows Columns 关系型数据库 数据库 表 行 列 Elasticsearch Indices Types Documents Fields 搜索引擎 索引 类型 文档 域（字段） 使用 Spring Data ElasticSearch_liuxigiant的专栏-CSDN博客 基于注解的配置 - Spring-Data-Elasticsearch Logstash Logstash：收集、解析和转换日志 | Elastic Kibana ELK：ELK 技术栈（ElasticSearch, Logstash, Kibana）搭建实时日志分析平台，将日志保存到 Elasticsearch 中，通过 Logstash 进行分析，并使用 Kibana 来展示和查询。 Lucene、Solr TODO SOFAStack 项目 · SOFAStack，是一套用于快速构建金融级云原生架构的中间件，也是在金融场景里锤炼出来的最佳实践。 SOFAJRaft SOFAJRaft 是一个基于 RAFT 一致性算法的生产级高性能 Java 实现，支持 MULTI-RAFT-GROUP，适用于高负载低延迟的场景。 分布式 理论基石 CAP 原理： C - Consistent ，一致性 A - Availability ，可用性 P - Partition tolerance ，分区容忍性 但——网络分区发生时，一致性和可用性两难全 主要算法 一致性 Hash redis 分片 分布式集群中，生成全局唯一的ID UUID String uuid = UUID.randomUUID().toString() 虽然可以保证全局唯一，但占用32位太长，而且无序，入库时性能比较差。 为什么无序的UUID会导致入库性能变差呢？ 这就涉及到 B+树索引的分裂：关系型数据库的索引大都是B+树的结构，拿ID字段来举例，索引树的每一个节点都存储着若干个ID。如果我们的ID按递增的顺序来插入，比如陆续插入8，9，10，新的ID都只会插入到最后一个节点当中。当最后一个节点满了，会裂变出新的节点。这样的插入是性能比较高的插入，因为这样节点的分裂次数最少，而且充分利用了每一个节点的空间。但是，如果我们的插入完全无序，不但会导致一些中间节点产生分裂，也会白白创造出很多不饱和的节点，这样大大降低了数据库插入的性能。 数据库自增主键 为了提高性能，在分布式系统中可以用DB proxy请求不同的分库，每个分库设置不同的初始值，步长和分库数量相等 这样一来，DB1生成的ID是1,4,7,10,13....，DB2生成的ID是2,5,8,11,14..... 但这样也不是很好。ID的生成对数据库严重依赖，影响性能，一旦数据库挂掉，服务将变得不可用。 SnowFlake 漫画：什么是SnowFlake算法？ 网络通信 RPC RPC 涉及：通讯，序列化，超时，重发（重复），消息顺序，负载 等等。（个人理解） 协议：thrift、gRPC 等等 JavaRMI 深究 Java 中的 RMI 底层原理 HSF 阿里巴巴集团内部使用的分布式服务框架 High Speed Framework Dubbo 一致性 分布式锁 分布式锁一般有三种实现方式： 数据库乐观锁； 基于 Redis 的分布式锁；（看数据库/Redis篇） 基于 ZooKeeper 的分布式锁 分布式事务 和分布式锁的区别 要捋清一些概念： 分布式事务指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。 简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。 本质上来说，分布式事务就是为了保证不同数据库的数据一致性。 共识算法 Paxos、Raft、Zab： 分布式事务与一致性算法 Paxos & raft & zab 分布式事务一致性的常见解决方案 2PC，3PC XA 消息中间件最终一致性 参考： 分布式一致性算法2PC和3PC_fcj的技术博客_51CTO博客 Java 分布式事务规范 JTA / XA JTA 是 Java 的事务管理器规范 XA 是工业标准的 X/Open CAE 规范，可被两阶段提交及回滚的事务资源定义 参考： atomikos:4.0 atomikos JTA/XA 全局事务 xaresource 分布式事务 分布式事务系列（2.1）分布式事务的概念 分布式 session 一致性 session 复制，对 web 服务器 (例如 Tomcat) 进行搭建集群 session 绑定，使用 nginx ip-hash 策略，无论客户端发送多少次请求都被同一个服务器处理 基于 redis 存储，spring 为我们封装好了 spring-session，直接引入依赖即可 高可用 缓存、降级、限流 服务器端如何处理超大量合法请求？ 服务器架构层面，做负载均衡，将请求分发给其它服务器处理。 软件服务架构层面，做请求队列，将 1w 个请求放入队列，业务处理完的请求再返回。 代码层面，优化业务处理，把单机请求做到支持 1w 并发。 容量设计 互联网架构，如何进行容量设计？_w3cschool 架构演进 从All in one 到微服务 架构师之路_w3cschool 前沿技术 概述 Docker、中台、ServiceMesh(服务网格) 大数据、人工智能、区块链等 容器化 Docker 与 k8s 大数据 ODPS离线分析 Hive Spark Hadoop Hbase HDFS 大数据体系 Flink入门教程 人工智能 1.1.1 什么是神经网络 - 床长人工智能教程 (captainbed.net) 思想 Reative 编程 Reactive 响应式 (反应式) 编程 是一种新的编程风格，其特点是异步或并发、事件驱动、推送 PUSH 机制以及观察者模式的衍生。 JVM 应用：RxJava、Akka、Actors 模型、Vert.x、Webflux 领域驱动设计 他是综合软件系统分析和设计的面向对象建模方法，如今已经发展为一种针对大型复杂系统的领域建模与分析方法。 将要解决的业务概念和业务规则转换为软件系统中的类型及类型的属性与行为，通过合理运用面向对象的封装、继承、多态等设计要素，降低或隐藏整个系统的业务复杂性，并使得系统具有更好的扩展性，应对纷繁多变的现实业务问题。 ——抄录于《高可用可伸缩微服务架构：基于 Dubbo、Spring Cloud 和 Service Mesh》2.1 节 领域驱动设计在互联网业务开发中的实践 美团 DDD 实践 示例项目 代码评审 基本（规范，模块化，逻辑） 安全（表单校验，防攻击SQL注入，线程安全） 数据库（事务，sql优化） 性能 性能优化 CPU 伪共享问题 问题：二维数组按行和按列遍历效率（Java章节中有说明） 应用：netty 中的 FastThreadLocal 中 InternalThreadLocalMap（Java章节中有说明）；lmax disruptor 等 对象池 安全 Java 反序列化 java反序列化漏洞的一些gadget log4j CVE-2019-17571：log4j CVE-2021-44228： (环境搭建+复现) CVE-2021-44228 Apache Log4j 远程代码执行漏洞 安全漏洞之Log4j2漏洞复现绕过分析 dubbo 反序列化漏洞攻击原理(Dubbo反序列化漏洞剖析) Gadgetinspector 一款针对Java应用程序/库的字节码分析工具，它可以帮助研究人员寻找和分析Java应用程序中的反序列化小工具链（Gadget Chain） https://github.com/JackOfMostTrades/gadgetinspector Java 反序列化工具 gadgetinspector 初窥 源码学习 这些框架的源码都值得一看： spring dubbo zookeeper tomcat Copyright © Ariescat all right reserved，powered by Gitbook最后修改时间： 2022-03-08 13:30 "},"Awesome/数据结构与算法.html":{"url":"Awesome/数据结构与算法.html","title":"数据结构","keywords":"","body":"《数据结构与算法》 数据结构 链表，栈，队列 数组，矩阵 差分数组 哈希表 堆 一个可以被看做一棵树的数组 建堆过程？ 堆的调整？ 图 树 遍历 递归遍历，非递归遍历 种类 二叉树，也叫二叉搜索树、二叉查找树。英文 BST (Binary Sort Tree)。 平衡二叉树，全称平衡二叉搜索树，也叫AVL树。是一种自平衡的树。 完全二叉树 与 满二叉树 B树 与 B+树 B 树、B-树、B+树、B*树 区别？ B-tree 树即 B 树，是一种多路搜索树 B 树的两个明显特点 树内的每个节点都存储数据 叶子节点之间无指针相邻 B+树的两个明显特点 数据只出现在叶子节点 所有叶子节点增加了一个链指针 B*树是 B+树的变体，在 B+树的非根和非叶子结点再增加指向兄弟的指针 B+树相比 B 树的优势 单一节点存储更多的元素，使得查询的 IO 次数更少； 所有查询都要查找到叶子节点，查询性能稳定； 所有叶子节点形成有序链表，便于范围查询。 要了解一下他们的查找，插入，删除 2-3树 与 2-3-4树 2-3树中每一个节点都具有两个孩子（我们称它为2节点）或三个孩子（我们称它为3节点）。 红黑树 查找（一）史上最简单清晰的红黑树讲解 - CSDN 博客 查找（二）简单清晰的 B 树、Trie 树详解 - CSDN 博客 Treap Trie，字典树，哈佛曼树 跳跃表 布隆过滤器，位图，hyperloglog 倒排索引 并查集 算法 基础算法 排序 八大排序算法比较： 希尔排序 时间复杂度？ 堆排序 如何建堆 和调整堆？ 快排 选择基准的方式：固定位置、随机选取基准、三数取中（三种快排） 快排最好最坏的情况？优化方案？ 优化方式： 优化1：当待排序序列的长度分割到一定大小后，使用插入排序 优化2：在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割 优化3：优化递归操作 优化4：使用并行或多线程处理子序列（略） （了解三路快排、双基准） 快排是二路划分的算法。如果待排序列中重复元素过多，也会大大影响排序的性能。这时候，如果采用三路划分，则会很好的避免这个问题。 归并排序 其他 Java 中Colletions.sort和Arrays.sort分别用了什么排序算法呢 算法与数据结构 这里给出了双路快排，三路快排，自底向上的归并排序算法等解析 附：关于他双路快排的实现： while ((i left + 1) && (arr[j] > v)) j--; // 使用索引 j 从右往左遍历直到 arr[j] > v 个人认为还可以优化，把相等的情况考虑进去，如下： while ((i left + 1) && (arr[j] >= v)) j--; // 使用索引 j 从右往左遍历直到 arr[j] > v 查找 二分查找 选取mid时，(r + l) / 2 这里的加法可能回产生整型溢出， 解决办法：l + (r - l) / 2 索引，倒排索引 双指针 KPM 算法 阮一峰 字符串匹配的 KMP 算法 补充：这篇博客的数组并不是 next 数组，而是\"部分匹配值\"数组，就是\"前缀\"和\"后缀\"的最长的共有元素的长度 CSDN KMP 算法—终于全部弄懂了 该博客分析了k = next[k]的问题 kpm 算法 - u012361418 的博客 - CSDN 博客 KMP 算法及优化 - 疯狂的爱因斯坦 - SegmentFault 该博客讲解了 KPM 的优化问题 树、图 树 深度遍历 前序、中序、后序 递归、非递归 广度遍历 最小生成树算法：Kruskal 算法，Prim 算法 图 最短路径算法：Dijkstra 算法，Bellman-Ford 算法，Floyd 算法和 SPFA 算法 进阶算法 五大常用算法 贪婪（贪心）算法，动态规划算法，分治算法，回溯算法以及分支限界算法 五大常用算法详解高广超的博客-CSDN博客算法 递归 斐波那契数列，其时间复杂度和空间复杂度 递推 动态规划就是递推的思想 算法洗脑系列（8 篇）——第一篇 递推思想 - 一线码农 - 博客园 常见动态规划问题总结 最长公共子序列与最长公共子串 (DP) 最长递增子序列 解法 1：最长公共子序列法 解法 2：动态规划法（时间复杂度 O(N^2)) dp[i] 表示以标识为 i 的元素为递增序列结尾元素的最长递增子序列的长度 解法 3：O(NlgN）算法 b[i] 只是存储的对应长度为 i 的 LIS 的最小末尾 最长公共子序列 用 dp[i][j] 来表示 A 串中的前 i 个字符与 B 串中的前 j 个字符的最长公共子序列长度 最长公共子串 这个问题与上面的问题类似，区别点在于这里是子串，是连续的，令 dp[i][j] 表示 A 串中的以第 i - 1 个字符与 B 串中的以第 j - 1 个字符结尾的最长公共子串的长度 最小编辑代价问题 首先令 dp[i][j] 表示将 A 串中的前 i 个字符转换成 B 串中的前 j 个字符所需要的代价 分治法的经典问题——大整数相乘 启发式算法 遗传算法（GA） A* 算法（可拓展了解下 Navmesh） 时间空间复杂度 算法复杂度 多项式时间 一种是 O(1),O(log(n)),O(n^a) 等，我们把它叫做多项式级的复杂度，因为它的规模 n 出现在底数的位置；另一种是 O(a^n) 和 O(n!) 型复杂度，它是非多项式级的。后者的复杂度无论如何都远远大于前者，其复杂度计算机往往不能承受。原文 这里引出几个问题： NP 问题：就是可以（多知项式时间内）短时间内验证一个答案正确性的问题。 NP 完全问题：第一个条件，可以这么说，就是道你如果能解决 A 问题，则通过 A 问题可以解决 B 问题，那么回 A 问题比 B 问题复杂，当所有的问题都可以通过 A 问题的解决而解决的话，那么 A 问题就可以称为 NP 完全问题，第二个条件，就是答 A 问题属于 NP 问题。 经典题目 经典问题之字符串 Top K 问题 面试必备 | 不可不会的反转链表 最大公共子串 看一遍就理解：动态规划详解 青蛙跳阶问题：递归时的重复计算问题 递增子序列：看一下解题思路：穷举分析，确定边界，找规律，确定状态转移方程 有意思的题目 摩尔投票法 面试题 17.10. 主要元素 求众数 II GCD，它通常表示最大公约数（greatest common divisor） 欧几里德算法又称辗转相除法，是指用于计算两个正整数a，b的最大公约数。应用领域有数学和计算机两个方面。计算公式gcd(a,b) = gcd(b,a mod b)。 面试题 微软经典面试100题系列（部分）Jack Zhou的专栏-CSDN博客微软面试题 直通BAT面试算法精讲课C++Java前端经典笔试面试题精讲牛客网 (nowcoder.com) 牛课堂系列算法讲座_牛客网 (nowcoder.com) 练习平台 剑指 Offer LeetCode 牛客笔试面试题库 书单 《 算法导论 》 《 算法(第4版) 》 Copyright © Ariescat all right reserved，powered by Gitbook最后修改时间： 2022-03-08 13:30 "},"Awesome/数据库.html":{"url":"Awesome/数据库.html","title":"MySQL","keywords":"","body":"《数据库》 MySQL 数据类型 MySQL 中的 int(M)，int(M) 里的 M 表示最大显示宽度，当加上 zerofill 才会表现出效果来。 unsigned 编码 utf8_general_ci、utf8_unicode_ci 和 utf8_bin 的区别 彻底解决 mysql 中文乱码 - CSDN 博客 SQL 语句 select select: 即最常用的查询，是不加任何锁的 select ... lock in share mode: 会加共享锁 (Shared Locks) select ... for update: 会加排它锁 联接子句 union，join 范式 第一范式：1NF是对属性的原子性约束，要求属性具有原子性，不可再分解； 第二范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性； 第三范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。 没有冗余的数据库设计可以做到。但是，没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。具体做法是：在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，允许冗余。 锁 前言 表锁，页面锁，行锁，共享锁，排它锁，意向锁，记录锁，间隙锁，临键锁......这些都是什么鬼？？？ 机制 共享锁（读锁，S 锁） 又称读锁，若事务 T 对数据对象 A 加上 S 锁，则事务 T 可以读 A 但不能修改 A，其他事务只能再对 A 加 S 锁，而不能加 X 锁，直到 T 释放 A 上的 S 锁。 这保证了其他事务可以读 A，但在 T 释放 A 上的 S 锁之前不能对 A 做任何修改。 排他锁（写锁，X 锁） 又称写锁。若事务 T 对数据对象 A 加上 X 锁，事务 T 可以读 A 也可以修改 A，其他事务不能再对 A 加任何锁，直到 T 释放 A 上的锁。 这保证了其他事务在 T 释放 A 上的锁之前不能再读取和修改 A。 粒度 MySQL 不同的存储引擎支持不同的锁机制 表锁：开销小，加锁快；不会出现死锁 行锁：开销大，加锁慢；会出现死锁 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁 默认情况下，表锁和行锁都是自动获得的，不需要额外的命令。 InnoDB 行级锁和表级锁 InnoDB 存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。 为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁： 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。 InnoDB 加锁方法 意向锁是 InnoDB 自动加的， 不需用户干预。 对于 UPDATE、 DELETE 和 INSERT 语句， InnoDB 会自动给涉及数据集加排他锁（X)； 对于普通 SELECT 语句，InnoDB 不会加任何锁； 事务可以通过以下语句显式给记录集加共享锁或排他锁： 共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。 其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。 排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁 锁只有在执行 commit 或者 rollback 的时候才会释放，并且所有的锁都是在同一时刻被释放。 InnoDB 行锁实现方式 InnoDB 行锁是通过给索引上的索引项加锁来实现的，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！ InnoDB 的间隙锁 当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB 会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB 也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key 锁）。 MySQL 默认事务隔离级别是可重复读，这个隔离级别为了避免幻读现象，引入了这个间隙锁，对索引项之间的间隙上锁。 SELECT * FROM t_url_mapping WHERE id>3 LOCK IN SHARE MODE;（SELECT 语句默认不上锁，需显示加锁，该语句加的就是间隙锁） 个人理解： 记录锁（Record Locks）：封锁记录，记录锁也叫行锁；例如： SELECT * FROM test WHERE id=1 FOR UPDATE; 间隙锁（Gap Lock）：锁在索引之间或者第一个索引前面或者最后一个索引后面。是一种概念，InnoDB 的算法实现是 Next-key lock，也属于间隙锁，但他相当于记录锁+间隙锁。 临键锁（Next-key lock）：使用索引进行范围查询，左开右闭区间，目的是为了解决幻读的问题。 注意死锁 产生：两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。如： 当前事务获得 S 锁，但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。 更新操作必须等待先执行的事务 commit 后才能执行，如果同时并发太大的时候很容易造成死锁。（搜索mysql in share mode 死锁） 检测死锁：数据库系统实现了各种死锁检测和死锁超时的机制。InnoDB 存储引擎能检测到死锁的循环依赖并立即返回一个错误。 死锁恢复：死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁，InnoDB 目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。 参考链接：MySQL 锁总结 事务 事务特性，ACID 的含义 原子性 a. 事务是一个原子操作单元 b. 要么都做，要么都不做，没有第三种情况 c. 原子性仅能够保证单个事务的一致性! 一致性 a. 事务操作前和操作后都必须满足业务规则约束 b. 比如资源数量一致：A 向 B 转账，转账前和转账后 AB 两个账户的总金额必须是一致的 c. 一致性是最基本的属性，其它的三个属性都为了保证一致性而存在的。为了保证并发情况下的一致性，引入了隔离性，即保证每一个事务能够看到的数据总是一致的，就好象其它并发事务并不存在一样。 隔离性 a. 多个并发事务同时对数据进行读写的能力 b. 隔离性可以防止事务并发执行时由于交叉执行导致数据不一致的问题 持久性 a. 对数据的修改是永久的 b. 即使出现系统故障也不会丢失 并发问题： 脏读 一个事务正在对一条记录做修改，在这个事务提交之前，别的事务读取到了这个事务修改之后的数据，也就是说，一个事务读取到了其他事务还没有提交的数据，就叫做脏读。 不可重复读（第一类不可重复读） 一个事务读某条数据读两遍，读到的是不一样的数据，也就是说，一个事务在进行中读取到了其他事务对旧数据的修改结果。（比如说 我开一个事务 修改某条数据 先查后改 执行修改动作的时候发现这条数据已经被别的事务删掉了） 幻读（第二类不可重复读） 一个事务中，读取到了其他事务新增的数据，仿佛出现了幻象。（幻读与不可重复读类似，不可重复读是读到了其他事务 update/delete 的结果，幻读是读到了其他事务 insert 的结果） 隔离级别： 读未提交（read-uncommitted） 在一个事务中，可以读取到其他事务未提交的数据变化，这种读取其他会话还没提交的事务，叫做脏读现象，在生产环境中切勿使用。 读已提交（read-committed） Sql Server,Oracle 默认 在一个事务中，可以读取到其他事务已经提交的数据变化，这种读取也就叫做不可重复读，因为两次同样的查询可能会得到不一样的结果。 可重复读（repetable-read） MySQL 默认 在一个事务中，直到事务结束前，都可以反复读取到事务刚开始时看到的数据，并一直不会发生变化，避免了脏读、不可重复读现象，但是在 SQL 标准中它还是无法解决幻读问题。 可串行化（serializable） 这是最高的隔离级别，它强制事务串行执行，避免了前面说的幻读现象，简单来说，它会在读取的每一行数据上都加锁，所以可能会导致大量的超时和锁争用问题。 几个概念： 锁：Shared Locks(共享锁/S 锁)、Exclusive Locks(排它锁/X 锁)、Record Locks(行锁)、Gap Locks(间隙锁)、Next-Key Locks(间隙锁) Record Locks 是加在索引行 (对！是索引行！不是数据行！)，Gap Locks 和 Next-Key Locks 都属于索引锁 快照读（普通读）：snapshot read，通过 MVCC 机制读取历史数据的方式 select * from table .... 当前读：current read ，读取数据库最新版本数据的方式 insert、update、delete、select for update、select lock in share mode 意向锁：表级别锁 隔离性底层实现原理： MVCC(多版本并发控制) 和锁 读已提交和可重复读区别主要在于MVCC 版本的生成时机 RC 是是每次select时，RR 是第一次select时生成版本 可串行化级别下，会自动将所有普通select转化为select ... lock in share mode执行，即针对同一数据的所有读写都变成互斥的了，可靠性大大提高，并发性大大降低。 注意： 间隙锁锁住的是索引的间隙，可以理解为范围，如（2，5]，(5，7] 我们通过update、delete等语句加上的锁都是行级别的锁。只有LOCK TABLE … READ和LOCK TABLE … WRITE才能申请表级别的锁。 RR 级别下隐藏着一个操作，就是在事务 A 提交前，事务 B 已经进行过一次查询，否则，事务 B 会读取最新的数据。原文 为什么很多文章都产生误传，说是可重复读可以解决幻读问题！原因出自官网的一句话 (地址是:https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-record-locks)，原文内容如下 By default, InnoDB operates in REPEATABLE READ transaction isolation level. In this case, InnoDB uses next-key locks for searches and index scans, which prevents phantom rows (see Section 14.7.4, “Phantom Rows”). 按照原本这句话的意思，应该是 InnoDB 默认用了 REPEATABLE READ。在这种情况下，使用 next-key locks 解决幻读问题！ 结果估计，某个国内翻译人员翻着翻着变成了 InnoDB 默认用了 REPEATABLE READ。在这种情况下，可以解决幻读问题！ 然后大家继续你抄我，我抄你，结果你懂的！ 显然，漏了\"使用了 next-key locks！\"这个条件后，意思完全改变，我们在该隔离级别下执行语句 select * from tx_tb where pId >= 1; 是快照读，是不加任何锁的，根本不能解决幻读问题，除非你用 select * from tx_tb where pId >= 1 lock in share mode; 这样，你就用上了 next-key locks，解决了幻读问题！ 其实幻读很多时候是我们完全可以接受的 总结： 隔离级别 读数据一致性 脏读 不可重复读 幻读 读未提交 最低级别，只保证不读取物理上损坏的数据 有 有 有 读已提交 语句级 无 有 有 可重复读 事务级 无 无 可能有 可串行化 最高级别，事务级 无 无 无 参考链接： 深入理解 mysql 的事务隔离级别和底层实现原理 Mysql 中 select 的正确姿势，新说 Mysql 事务隔离级别，他的“数据库系列”都挺不错的 事务传播（其实这个是Spring的概念，Spring 它对 JDBC 的隔离级别作出了补充和扩展，其提供了 7 种事务传播行为） PROPAGATION_REQUIRED：默认事务类型，如果没有，就新建一个事务；如果有，就加入当前事务。适合绝大多数情况。 PROPAGATION_REQUIRES_NEW：如果没有，就新建一个事务；如果有，就将当前事务挂起。 PROPAGATION_NESTED：如果没有，就新建一个事务；如果有，就在当前事务中嵌套其他事务。 PROPAGATION_SUPPORTS：如果没有，就以非事务方式执行；如果有，就使用当前事务。 PROPAGATION_NOT_SUPPORTED：如果没有，就以非事务方式执行；如果有，就将当前事务挂起。即无论如何不支持事务。 PROPAGATION_NEVER：如果没有，就以非事务方式执行；如果有，就抛出异常。 PROPAGATION_MANDATORY：如果没有，就抛出异常；如果有，就使用当前事务。 索引 使用场景 索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效。 对于中到大型的表，索引就非常有效。 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。 是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，可以通过 explain 检查 SQL 的执行计划，比如上面第一种情况，它就不会使用索引 B-Tree 查找算法：首先在根节点进行二分查找，如果找到则返回对应节点的 data，否则在相应区间的指针指向的节点递归进行查找。 B+Tree 相比 B-Tree： 内节点不存储 data，只存储 key； 叶子节点不存储指针。 一般在数据库系统或文件系统中使用的 B+Tree 结构都在经典 B+Tree 基础上进行了优化，在叶子节点增加了顺序访问指针，做这个优化的目的是为了提高区间访问的性能。 利用计算机预读特性 操作系统一般将内存和磁盘分割成固态大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点，并且可以利用预读特性，相邻的节点也能够被预先载入。 B+Tree 索引 InnoDB 的 B+Tree 索引分为主索引和辅助索引。 主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。 辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。 MySQL 索引类型 唯一索引，主键（聚簇）索引，非聚簇索引，全文索引 其实按照定义，除了聚集索引以外的索引都是非聚集索引，只是人们想细分一下非聚集索引，分成普通索引，唯一索引，全文索引。 全文索引有自己的语法格式，使用 match 和 against 关键字，比如 select * from fulltext_test where match(content,tag) against('xxx xxx'); 缺点 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加 索引需要占用物理空间，除了数据表占用数据空间之外，每一个索引还要占一定的物理空间，如果建立聚簇索引，那么需要的空间就会更大 当对表中的数据进行增加、删除和修改的时候，索引也需要维护，降低数据维护的速度 索引失效 如果条件中有 or，即使其中有条件带索引也不会使用 (这就是问什么尽量少使用 or 的原因) 对于多列索引，不是使用的第一部分，则不会使用索引 like 查询是以%开头 如果列类型是字符串，那一定要在条件中使用引号引起来，否则不会使用索引 如果 MySQL 估计使用全表扫秒比使用索引快，则不适用索引。 在什么情况下适合建立索引 order by、group by、distinct union where、join 联合索引 最左前缀匹配原则 mysql联合索引 - 沧海一滴 - 博客园 mysql 会一直向右匹配直到遇到范围查询 (>、 3 and d = 4 如果建立 (a,b,c,d) 顺序的索引，d 是用不到索引的，如果建立 (a,b,d,c) 的索引则都可以用到，a,b,d 的顺序可以任意调整。 MYSQL 如何挑选索引？ 参考链接 MySQL 索引总结 我以为我对Mysql索引很了解，直到我遇到了阿里的面试官_HollisChuang's Blog-CSDN博客 数据库索引是如何工作的？ - 程序员和软件面试问题和答案 (programmerinterview.com) 一通骚操作，我把SQL执行效率提高了10000000倍！ - 知乎 存储引擎 MyISAM，InnoDB MySQL默认采用的是InnoDB。 了解他们的主要区别。 日志 日志类型 逻辑日志：存储了逻辑 SQL 修改语句 物理日志：存储了数据被修改的值 binlog MySQL 的逻辑日志，也叫二进制日志、归档日志，用于记录用户对数据库操作的 SQL 语句（除了查询语句）信息，以二进制的形式保存在磁盘中。 日志格式：STATMENT、ROW 和 MIXED STATMENT：基于 SQL 语句的复制，每一条会修改数据的 sql 语句会记录到 binlog 中，是 binlog 的默认格式。 ROW：基于行的复制，不记录每一条 SQL 语句的上下文信息，仅保存哪条记录被修改。 MIXED 模式是基于 STATMENT 和 ROW 两种模式的混合复制，一般的复制使用 STATEMENT 模式保存 binlog，对于 STATEMENT 模式无法复制的操作使用 ROW 模式保存 binlog，MySQL 会根据执行的 SQL 语句选择日志保存方式。 redo/undo log redo log 是 MySQL 的物理日志，也叫重做日志，记录存储引擎 InnoDB 的事务日志。 MySQL 每执行一条 SQL 更新语句，不是每次数据更改都立刻写到磁盘，而是先将记录写到 redo log 里面，并更新内存（这时内存与磁盘的数据不一致，将这种有差异的数据称为脏页），一段时间后，再一次性将多个操作记录写到到磁盘上，这样可以减少磁盘 io 成本，提高操作速度。先写日志，再写磁盘，这就是 MySQL 里经常说到的 WAL 技术，即 Write-Ahead Logging，又叫预写日志。MySQL 通过 WAL 技术保证事务的持久性。 Crash Safe（宕机重启）： 有了 redo log，当数据库发生宕机重启后，可通过 redo log 将未落盘的数据（check point 之后的数据）恢复，保证已经提交的事务记录不会丢失，这种能力称为 crash-safe。 两阶段提交： 有了 redo log，为什么还需要 binlog 呢？先来看看 binlog 和 redo log 的区别： redo log binlog 文件大小 redo log 的大小是固定的。 binlog 可通过配置参数 max_binlog_size 设置每个 binlog 文件的大小。 实现方式 redo log 是 InnoDB 引擎层实现的，并不是所有引擎都有。 binlog 是 Server 层实现的，所有引擎都可以使用 binlog 日志。 记录方式 redo log 采用循环写的方式记录，当写到结尾时，会回到开头循环写日志。日志上的记录修改落盘后，日志会被覆盖掉，无法用于数据回滚/数据恢复等操作。 binlog 通过追加的方式记录，当文件大小大于给定值后，日志会发生滚动，之后的日志记录到新的文件上，不会覆盖以前的记录。 由 binlog 和 redo log 的区别可知：binlog 日志只用于归档，只依靠 binlog 是没有 crash-safe 能力的。但只有 redo log 也不行，因为 redo log 是 InnoDB 特有的，且日志上的记录落盘后会被覆盖掉。因此需要 binlog 和 redo log 二者同时记录，才能保证当数据库发生宕机重启时，数据不会丢失。 参考链接 MySQL 的日志系统 Crash Safe 和 Binlog 的关系 备份与恢复 冷备份，热备份 cp，mysqldump，lvm2 快照，xtrabackup mysql 误删数据快速恢复 高级 explain explain 显示了 mysql 如何使用索引来处理 select 语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句。 如何快速的删除一张大（TB 级别）表？ 区分 drop，truncate，delete 利用 linux 中硬链接 慢日志 可以设置一个时间，那么所有执行时间超过这个时间的 SQL 都会被记录下来。这样就可以通过慢日志快速的找到网站中 SQL 的瓶颈来进行优化。 分布式 主从复制，分库分表 分布式锁 Redis 概述 Redis 是一种基于键值对 (Key-Value) 的 NoSQL 数据库，Redis 的 Value 的基础数据结构有 string、list、hash、set、zset； 有 Bitmaps，HyperLogLog 等多种高级数据结构和算法 Redis 还提供了键过期，发布订阅，事务，Lua 脚本，哨兵，Cluster 等功能 Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能 数据类型 string、list、hash、set、zset 选择 选择 hash 还是 string 存储数据？ 编码 encoding 记录了对象所保存的值的编码 下图展示了 redisObject 、Redis 所有数据类型、以及 Redis 所有编码方式（底层实现）三者之间的关系： 数据结构 字典 dictht 跳跃表，是有序集合的底层实现之一 5.0新数据结构Stream 过期 Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。 对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。 淘汰 可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。 LRU 算法和 LFU 算法，redis 对 LRU 的改进 高可用 主从复制 Sentinel，Codis，Cluster 数据一致性 产生原因 并发的场景下，导致读取老的 DB 数据，更新到缓存中。 缓存和 DB 的操作，不在一个事务中，可能只有一个操作成功，而另一个操作失败，导致不一致。 更新缓存的设计模式 Cache Aside Pattern（旁路缓存，常用） 失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。 命中：应用程序从cache中取数据，取到后返回。 更新：先把数据存到数据库中，成功后，再让缓存失效。 Read/Write Through Pattern 把更新数据库的操作由缓存自己代理了，但Cache自己更新数据库是一个同步操作 Write Behind Caching Pattern（游戏开发会常用） Write Behind 又叫 Write Back。Write Behind 就是 Linux 文件系统的 Page Cache 算法。 Write Back套路，一句说就是，在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。 这个设计的好处就是让数据的 I/O 操作飞快无比（因为直接操作内存嘛），因为异步，write backg 还可以合并对同一个数据的多次操作，所以性能的提高是相当可观的。 数据库与缓存双写问题 思考 按照Cache Aside Pattern的更新，这种方式真的没问题吗？ 最终一致性的解决方案 从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。 这种方案下，我们可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。 不依赖于给缓存设置过期时间的方案： 先更新数据库，再更新缓存 会有冷数据（多写少读） 先删除缓存，再更新数据库 A线程删缓存但未更新DB，B线程读并写入缓存导致脏数据。解决方案是使用延迟双删（第二次删除失败怎么办?） 先更新数据库，再删除缓存 缓存刚好失效，A线程读并写入缓存，过程中穿插了B线程的更新DB删除缓存。概率极小，该方案可满足大部分的应用场景。 （为什么没有先更新缓存，再更新数据库这种策略？若先更新缓存，缓存更新成功，但是更新数据库时发生异常导致回滚，那么缓存中的数据无法回滚，导致数据不一致。看产生原因的第二点） 删除缓存失败： 解决方案是消息队列或者其他 binlog 同步，引入消息队列会带来更多的问题，并不推荐直接使用。 参考： 缓存的双写一致性解决方案 解决redis与mysql数据一致性 看不懂的你来打我~_kingtok的博客 一致性恢复方案 TODO 如果出现了问题，怎么解决？ 主从DB与cache一致性 TODO 回顾一下分布式事务一致性，别混淆 应用场景 分布式锁、延时队列、位图、HyperLogLog、布隆过滤器、简单限流（zset）、漏斗限流、GeoHash（地理位置） 限流 Redis应用-限流 - 掘金 (juejin.cn) 分布式锁 单实例中实现分布式锁： setnx（注意删除时最好使用 Lua 脚本删除，逻辑是先获取 key，如果存在并且值是自己设置的就删除此 key，否则就跳过） set key value px milliseconds nx（使用 set 代替 setnx，相当于 setnx + expire 实现了原子性，不必担心 setnx 成功，expire 失败的问题） 多节点 redis 实现的分布式锁 RedLock 可以看看 redission 的实现 参考： redis分布式锁深度剖析(超时情况) Redlock：Redis分布式锁最牛逼的实现 Redlock（redis分布式锁）原理分析 - RGC 缓存穿透解决方案 增加校验，缓存，布隆过滤器（Bloom Filter），hyperloglog 持久化 RDB 持久化 将某个时间点的所有数据都存放到硬盘上 AOF 持久化 将写命令添加到 AOF 文件（Append Only File）的末尾 技术 使用操作系统的多进程 COW(Copy On Write) 机制来实现快照持久化 bgsave 做全量持久化到 RDB 二进制文件中，aof 做增量持久化，存储的是文本协议数据 额外的知识点 Redis 的线程模型：单线程，IO 多路复用 客户端与服务器的通信协议 管道，事务 注意 redis 事务不保证原子性，不支持回滚。他总结来说：就是一次性、顺序性、排他性的执行一个队列中的一系列命令。其他客户端提交的命令请求不会插入到事务执行命令序列中。 思考一下，为什么这样设计？ Info 指令 源码 带有详细注释的 Redis 3.0 代码 jemalloc，Redis 默认使用 jemalloc(facebook) 库来管理内存 一些面试题 《吊打面试官》系列-缓存雪崩、击穿、穿透 Java 的 Redis 客户端：Jedis，Redisson Redisson 不仅封装了 redis ，还封装了对更多数据结构的支持，以及锁等功能，相比于 Jedis 更加大。 Redisson 的加锁/释放锁都是用 Lua 脚本，相比于 setnx 就能实现，为何多此一举？仔细看 Lua 脚本就会发现考虑得非常全面，其中包括锁的重入性。 但 Jedis 相比于 Redisson 更原生一些，更灵活。 Redis模块 ReJSON模块 ReJSON 是一个Redis Module，它实现了ECMA-404 The JSON Data Interchange Standard作为本地数据类型，它允许从Redis Keys（documents）中存储，更新和获取 JSON 值 主要特性： 完全支持JSON标准 对于在文档内选择元素类似 JSONPath 语法 文档作为二进制数据被存储在一个树形结构中，允许快速访问子元素 对所有 JSON 数据类型按照原子操作进行分类 ReJSON 是由 Redis Labs 开发的，源码下载地址是 https://github.com/RedisLabsModules/ReJSON 书籍 《redis 设计与实现 (第二版)》 《Redis 深度历险:核心原理与应用实践》 Memcache Redis 之与 Memcached 的比较 MongoDB 为什么 Mongodb 索引用 B 树，而 Mysql 用 B+树? Oracle 冷备份 正常关闭数据库 备份所有重要的文件到备份目录（数据文件、控制文件、重做日志文件等） 完成备份后启动数据库 热备份 数据恢复 几种oracle数据库恢复的练习示例 Copyright © Ariescat all right reserved，powered by Gitbook最后修改时间： 2022-03-08 13:30 "},"Awesome/网络.html":{"url":"Awesome/网络.html","title":"计算机网络","keywords":"","body":"《网络》 计算机网络 OSI 七层模型与 TCP/IP 四层（参考）模型 协议 底层网络协议 ARP，ICMP（网际控制信息协议），路由选择，DHCP，NAT TCP/IP 跟着动画来学习 TCP 三次握手和四次挥手 三次挥手是确保双方都能收和发的最少确认次数 四次挥手中间的两步并不总是会合成一步走，因为服务端处于“半关闭状态”，可能还有剩下的消息没发完，客户端此时能收不能发 四次挥手的 time_wait 状态，2MSL(MSL 为报文最大生存时间，一般 2 分钟，可更改)，作用是重传最后一个 ack 报文 TCP 的三次握手与四次挥手（详解+动图） 拥塞算法：慢开始 、 拥塞避免 、快重传 和 快恢复 两者的区别：流量控制是为了预防拥塞。如：在马路上行车，交警跟红绿灯是流量控制，当发生拥塞时，如何进行疏散，是拥塞控制。流量控制指点对点通信量的控制。而拥塞控制是全局性的，涉及到所有的主机和降低网络性能的因素。 TCP 和 UDP 的区别 TCP/IP 协议是一个协议簇。里面包括很多协议的。UDP 只是其中的一个。之所以命名为 TCP/IP 协议，因为 TCP,IP 协议是两个很重要的协议，就用他两命名了。原文 网络编程懒人入门(四)：快速理解TCP和UDP的差异 http/https 彻底掌握网络通信 (httpclien，asynchttpclient，HttpURLConnection，OkHttp3) 一次经典的错误：https://github.com/Ariescat/lqz-test/blob/master/base-test/src/main/http/http.log websocket ping 的实现： 首先查本地 arp cache 信息，看是否有对方的 mac 地址和 IP 地址映射条目记录 如果没有，则发起一个 arp 请求广播包，等待对方告知具体的 mac 地址 收到 arp 响应包之后，获得某个 IP 对应的具体 mac 地址，有了物理地址之后才可以开始通信了,同时对 ip-mac 地址做一个本地 cache 发出 icmp echo request 包，收到 icmp echo reply 包 反向代理为何叫反向代理？原文 IPv6 网络编程懒人入门(十一)：一文读懂什么是IPv6-网络编程 网络安全 攻击 DDoS 攻击 XSS攻击 非对称加密 在非对称加密中使用的主要算法有：RSA、Elgamal、Rabin、D-H（Diffie-Hellman）、ECC（椭圆曲线加密算法）等 https https 客户端无法判断自己收到的服务器的公钥是否是正确的，是否在服务器发送给客户端的过程中被第三方篡改了，所以还需要证明公开密钥正确性的数字证书。 https 可以解决中间人劫持？ ssl/tls 了解他们的握手过程 ssh 数字签名，数字证书 浏览器一般怎样校验证书呢？ 了解几个本质：（原文） 解决内容可能被窃听的问题——非对称加密 解决报文可能遭篡改问题——数字签名 解决通信方身份可能被伪装的问题——认证 oauth协议 如果不理解oauth协议的推荐阅读 阮一峰的 理解OAuth 2.0 Socket 同步阻塞概念 同步、异步： 概念：消息的通知机制 解释：涉及到 IO 通知机制；所谓同步，就是发起调用后，被调用者处理消息，必须等处理完才直接返回结果，没处理完之前是不返回的，调用者主动等待结果；所谓异步，就是发起调用后，被调用者直接返回，但是并没有返回结果，等处理完消息后，通过状态、通知或者回调函数来通知调用者，调用者被动接收结果。 阻塞、非阻塞： 概念：程序等待调用结果时的状态 解释：涉及到 CPU 线程调度；所谓阻塞，就是调用结果返回之前，该执行线程会被挂起，不释放 CPU 执行权，线程不能做其它事情，只能等待，只有等到调用结果返回了，才能接着往下执行；所谓非阻塞，就是在没有获取调用结果时，不是一直等待，线程可以往下执行，如果是同步的，通过轮询的方式检查有没有调用结果返回，如果是异步的，会通知回调。 I/O 模型 阻塞式 I/O 非阻塞式 I/O I/O 复用 信号驱动 I/O 异步 I/O 五大 I/O 模型比较 参考链接： IO 复用,AIO,BIO,NIO,同步，异步，阻塞和非阻塞 区别 网络 IO 中的同步、异步、阻塞和非阻塞 迄今为止把同步/异步/阻塞/非阻塞/BIO/NIO/AIO 讲的最清楚的好文章 《Netty Zookeeper Redis 高并发实战》2.2 节 Reactor 模式 TODO 零拷贝 传统的文件传输，DMA 技术 DMA 是一种允许外围设备（硬件子系统）直接访问系统主内存的机制。也就是说，基于 DMA 访问方式，系统主内存于硬盘或网卡之间的数据传输可以绕开 CPU 的调度。 参考：DMA 技术是什么，在哪里用？看完绝对有收获 - 简书 (jianshu.com) Linux 支持的 (常见) 零拷贝 mmap 内存映射，sendfile（linux 2.1 支持），Sendfile With DMA Scatter/Gather Copy（可以看作是 sendfile 的增强版，批量 sendfile），splice（linux 2.6.17 支持）。 Linux 零拷贝机制对比：无论是传统 IO 方式，还是引入零拷贝之后，2 次 DMA copy 是都少不了的。因为两次 DMA 都是依赖硬件完成的。 PageCache，磁盘高速缓存 主要是两个优点：缓存最近被访问的数据，预读功能 但是，在传输大文件（GB 级别的文件）的时候，PageCache 会不起作用，那就白白浪费 DRM 多做的一次数据拷贝，造成性能的降低，即使使用了 PageCache 的零拷贝也会损失性能 直接 I/O 大文件传输 「异步 I/O + 直接 I/O」来替代零拷贝技术 Java NIO 引入了用于通道的缓冲区的 ByteBuffer。 ByteBuffer 有三个主要的实现： HeapByteBuffer，DirectByteBuffer，MappedByteBuffer Netty 中的零拷贝 Netty 中的 Zero-copy 与上面我们所提到到 OS 层面上的 Zero-copy 不太一样, Netty 的 Zero-copy 完全是在用户态 (Java 层面) 的，它的 Zero-copy 的更多的是偏向于优化数据操作这样的概念。 Netty 提供了 CompositeByteBuf 类，它可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf，避免了各个 ByteBuf 之间的拷贝。 通过 wrap 操作，我们可以将 byte[] 数组、ByteBuf、 ByteBuffer 等包装成一个 Netty ByteBuf 对象，进而避免了拷贝操作。 ByteBuf 支持 slice 操作，因此可以将 ByteBuf 分解为多个共享同一个存储区域的 ByteBuf，避免了内存的拷贝。 通过 FileRegion 包装的 FileChannel.tranferTo 实现文件传输，可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环 write 方式导致的内存拷贝问题。 前三个都是 广义零拷贝，都是减少不必要数据 copy；偏向于应用层数据优化的操作。 参考： Java 中的零拷贝 这篇文章耐心看完，他讲的是真透彻，他从概念上区分了广义和狭义零拷贝，讲解了系统底层层面上的，JDK NIO 层面上的，Kafka、Netty 层面上的。 零拷贝 敖丙 IO 操作的真正耗时 我们开始以为 write 操作是要等到对方收到消息才会返回，但实际上不是这样的。write 操作只负责将数据写到本地操作系统内核的发送缓冲然后就返回了。剩下的事交给操作系统内核异步将数据送到目标机器。但是如果发送缓冲满了，那么就需要等待缓冲空出空闲空间来，这个就是写操作 IO 操作的真正耗时。 我们开始以为 read 操作是从目标机器拉取数据，但实际上不是这样的。read 操作只负责将数据从本地操作系统内核的接收缓冲中取出来就了事了。但是如果缓冲是空的，那么就需要等待数据到来，这个就是读操作 IO 操作的真正耗时。 这里可以配合《Netty、Redis、Zookeeper 高并发实战》2.2 节四种主要的 IO 模型来看一下。 Copyright © Ariescat all right reserved，powered by Gitbook最后修改时间： 2022-03-08 13:30 "},"Awesome/操作系统.html":{"url":"Awesome/操作系统.html","title":"操作系统","keywords":"","body":"《操作系统》 操作系统 进程管理 CPU调度 什么时候会发生 CPU 调度 当进程从运行状态转到等待状态； 当进程从运行状态转到就绪状态； 当进程从等待状态转到就绪状态； 当进程从运行状态转到终止状态； 其中发生在 1 和 4 两种情况下的调度称为「非抢占式调度」，2 和 3 两种情况下发生的调度称为「抢占式调度」。 非抢占式 当进程正在运行时，它就会一直运行，直到该进程完成或发生某个事件而被阻塞时，才会把 CPU 让给其他进程。 抢占式调度 顾名思义就是进程正在运行的时，可以被打断，使其把 CPU 让给其他进程。那抢占的原则一般有三种，分别是时间片原则、优先权原则、短作业优先原则。 算法 先来先服务调度算法 最短作业优先调度算法 高响应比优先调度算法 时间片轮转调度算法 最高优先级调度算法 多级反馈队列调度算法 进程和线程 进程间通信 管道，消息队列，共享内存 死锁 内存管理 分页管理 页、块、页表： 将虚拟地址空间以512Byte ~ 8K，作为一个单位，称为页，并从0开始依次对每一个页编号。 将物理地址按照同样的大小，作为一个单位，称为框或者块，也从0开始依次对每一个框编号。 操作系统通过维护一张表，这张表上记录了每一对页和框的映射关系，这张表，称为页表。 访问： 当CPU要访问一个虚拟地址空间对应的物理内存地址时，先将具体的虚拟地址A/页面大小4K，结果的商作为页表号，结果的余作为业内地址偏移。 内存页面置换 缺页中断 当 CPU 访问的页面不在物理内存时，便会产生一个缺页中断，请求操作系统将所缺页调入到物理内存 页面置换算法 最佳页面置换算法（OPT） 先进先出置换算法（FIFO） 最近最久未使用的置换算法（LRU） 时钟页面置换算法（Lock） 最不常用置换算法（LFU） 磁盘 磁盘寻道算法 Orther 设备管理 虚拟内存和 swap 分区 Windows hiberfil.sys 和 pagefile.sys 占用系统空间，其分别是休眠空间和虚拟内存。 模拟 linux 环境 wsl2（Windows Subsystem for Linux，Windows下的Linux子系统） cygwin64 虚拟机 VMware VirtualBox Linux 常用服务搭建 （Shadowsocks，Ngrok，Nginx...） CentOS7 Linux 如何查看端口状态_百度经验 Linux Yum 命令使用举例_Linux 教程_Linux 公社-Linux 系统门户网站 CentOS7 使用 firewalld 打开关闭防火墙与端口 - 莫小安 - 博客园 MySql CentOS 下的 Mysql 的安装和使用 - suxiaoman - 博客园 Jetty Centos6.8 Jetty 安装配置 - 那个汪 - 博客园 Shadowsocks 记一次搭建 SS 服务器，完整的过程。，搭建 ss_Linux 教程 · 帮客之家 Centos 7 下搭建 SS - CSDN 博客 Shadowsocks - Clients 锐速 ServerSpeeder 无限带宽破解版一键安装包 (2017.6.23 更新 )-蜗牛 789 Nginx Nginx 的一些基本功能 - CSDN 博客 Ngrok CentOS7.3 编译安装 go1.8.1 - Aliang Log CentOS 下部署 Ngrok 服务器 - YE_NICKNAME - CSDN 博客 Centos 下自己架设 ngrok 服务器（内网测试神器） - 个人文章 - SegmentFault 必备软件 系统镜像 https://msdn.itellyou.cn/ everything wox（window 快速搜索文件启动程序软件） HTTP 接口测试工具 Postman PanDownload Copyright © Ariescat all right reserved，powered by Gitbook最后修改时间： 2022-03-08 13:30 "},"Awesome/C++.html":{"url":"Awesome/C++.html","title":"C++基础","keywords":"","body":"《C++》 C++基础 基本类型 浮点数比较 fabs(f1-f2) 而abs()函数是针对整数的 字符串、向量和数组 string.h memcpy memset C 标准库 – | 菜鸟教程 (runoob.com) 动态申请二维数组 利用一个二级指针来实现 //5 行 2 列的数组 int **p = (int **)malloc(sizeof(int *) * 5); for (int i = 0; i 利用数组指针来实现 //申请一个 5 行 2 列的整型数组 int(*p)[2] = (int(*)[2])malloc(sizeof(int) * 5 * 2); //输出数组每个元素地址 printf(\"%p\\n\", &p[i][j]); 利用一维数组来模拟二维数组 int *p = (int *)malloc(sizeof(int) * 5 * 2); //输出数组每个元素地址 printf(\"%p\\n\", &p[i*2+j]); malloc返回的其实是void *，所以其需要强转，void *的用处还有memcpy，memset等 \"\\ddd\" 和 \"\\xhh\" 分别是什么意思? \"\\ddd\" 表示1~3位八进制数ddd对应的字符，例如 '\\141' 代表字符常量 'a' \"\\xhh\" 表示1~2位十六进制数hh对应的字符，例如 '\\x41' 代表字符常量 'A' 如：putchar('\\101')输出字符A；putchar('\\015')输出回车，不换行，使输出的当前位置移到本行开头 C++标准库 C++:STL（Standard Template Library，标准模板库） STL的代码从广义上讲分为三类：algorithm（算法）、container（容器）和iterator（迭代器），几乎所有的代码都采用了模板类和模版函数的方式，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。在C++标准中，STL被组织为下面的13个头文件： 、、、、、、、、、、、、。 #include包含C++的全部头文件 附：STL标准入门汇总 http://www.cnblogs.com/shiyangxt/archive/2008/09/11/1289493.html IO库 输入输出重定向 在默认情况下，cin 只能接收从键盘输入的数据，cout 也只能将数据输出到屏幕上。但通过重定向，cin 可以将指定文件作为输入源，同样 cout 可以将原本要输出到屏幕上的数据转而写到指定文件中。 实现： freopen()函数 rdbuf()函数 在控制台中使用 > 或者 C:\\Users\\mengma>D:\\demo.exe out.txt 打印格式 %3d 可以指定宽度，不足的左边补空格 %-3d 左对齐 %03d 一种左边补0 的等宽格式,比如数字12,%03d出来就是: 012 高级 结构体占用内存大小 内存对齐 是什么？ Copyright © Ariescat all right reserved，powered by Gitbook最后修改时间： 2022-03-08 13:30 "},"Awesome/其他编程语言.html":{"url":"Awesome/其他编程语言.html","title":"动态语言与动态类型语言","keywords":"","body":"《其他编程语言》 动态语言与动态类型语言 动态语言：(Dynamic programming Language -动态语言或动态编程语言)，动态语言是指程序在运行时可以改变其结构，新的函数可以被引进，已有的函数可以被删除等在结构上的变化。 动态类型语言：动态类型语言是指在运行期间才去做数据类型检查的语言，说的是数据类型，动态语言说的是运行是改变结构，说的是代码结构。 Groovy 30 分钟 groovy 快速入门并掌握 Groovy 语言快速入门 Groovy 与 Java 实战 Groovy，在 Java 应用程序中加一些 Groovy 进来 利用 SPRING 管理热加载的 GROOVY 对象 spring + groovy 很强大 Spring 动态部署 Bean/Controller/Groovy Controller Groovy as DSL 与 Gradle Gradle：新一代自动化构建工具 Groovy DSL 百度搜索 gradle dsl 前端 基础 HTML/CSS Flex 布局教程：语法篇 - 阮一峰的网络日志 (ruanyifeng.com) JavaScript 阿里巴巴的这道题为什么选A？为什么new main()输出的都是undefined？ - SegmentFault 思否 ECMAScript 框架 Bootstrap 教程 - 菜鸟教程 Moment.js 中文网 (momentjs.cn) Vue 双向数据绑定与单向数据绑定 Vuex，Weex vue 常用组件库_zhouzhiwengang的专栏-CSDN博客_vue组件库 React React 入门实例教程 Flux 架构 Flux 架构入门教程 状态管理 聊一聊主流前端框架的状态管理 前端状态管理请三思 其他 给 2019 前端的 5 个建议 浏览器原理系列 10 篇正式完结 跨平台 Weex Weex Weex-初次见到你-阿里云开发者社区 (aliyun.com) weex社区 - 专题 - 简书 (jianshu.com) 没有死！阿里公开Weex技术架构，还开源了一大波组件_我只是一个小小的搬运工的博客-CSDN博客 （总结）Weex若干特性总结分析 - 大球和二憨 - 博客园 (cnblogs.com) Weex Android SDK源码分析之Module（modal）_王永迪的专栏-CSDN博客 Weex Android交互篇_hzh839900的专栏-CSDN博客 Weex Ui Weex Ui (apache.github.io) Eros bmfe/eros: 📱 一套 Vue 代码，两端原生应用 ，或许可以叫我 weex-native。 (github.com) EROS (bmfe.github.io) Nat natjs/nat: A powerful kit for adding native functionalities to your weex app. (github.com) EMAS组件 Android Gradle Distributions 图表 hellocharts 权限 Android 6.0在运行时申请权限解释与实例_Widsom的博客-CSDN博客 学习网站 开发者指南 · Android 开发者 · Android Developers 使用 NavigationUI 更新界面组件 抽屉式导航栏 AndroidDevTools - Android 开发工具 Android SDK 下载 Android Studio 下载 Gradle 下载 SDK Tools 下载 android-open-source-project-analysis EventBus 3事件总线 从源码入手来学习EventBus 3事件总线机制 Material Design NavigationView FlaotingActionBar SnackBar Design Support Library RecyclerView SwipeRefreshLayout 控件点击水波纹 书籍 henrymorgen / android-advanced-decode 《Android 进阶解密》源码 Copyright © Ariescat all right reserved，powered by Gitbook最后修改时间： 2022-03-08 13:30 "},"Awesome/Game.html":{"url":"Awesome/Game.html","title":"游戏开发","keywords":"","body":"《Game》 游戏技术 网络 通信： 可靠 UDP 的实现：KCP TCP 启用和禁用TCP_NODELAY有什么影响？ 应用层协议： Json，MessagePack ProtoBuf AI 状态机 行为树 入门 Java游戏服务器开发之行为树_cmqwan的博客-CSDN 进阶 事件行为树 寻路 A* 及其变种算法 参考： 路径规划之 A* 算法 - 知乎 (zhihu.com) JPS 参考： 《2018腾讯移动游戏技术评审标准与实践案例》：寻路算法 JPS 优化章节 「游戏」寻路算法之JPS原理和实现_Echo-CSDN博客 JPS（Jump Point Search）寻路及实现代码分析_燕临江下的蛋-CSDN博客 [算法]小学堂：JPS寻路算法浅析 - 知乎 (zhihu.com) 导航网格（navmesh） 导航网格的生成会分为下面几个步骤： 场景模型体素化（Voxelization），或者叫“栅格化”（Rasterization） 过滤出可行走面（Walkable Suface） 生成 Region 生成 Contour（边缘） 生成 Poly Mesh 生成 Detailed Mesh 参考： 《腾讯游戏开发精粹》：第5章 3D游戏碰撞之体素内存、效率优化 游戏的寻路导航 1：导航网格 - 简书 (jianshu.com) NMGen Study 项目，NMGen研究是Java中 Recast静态网格 功能的改编，用于研究和实验目的。 Recast&Detour_游蓝海 的专栏-CSDN博客 寻路_长三月的游戏开发-CSDN博客 碰撞检测 碰撞检测的向量实现 - 掘金 (juejin.cn) 这里面的参考链接也可以看看 游戏框架 Akka Actor 模型 akka 设计模式系列-基础模式 skynet LuaAPI · cloudwu/skynet Wiki (github.com) skynet源码赏析 (manistein.github.io) skynet教程（1）--服务的编写 - 简书 (jianshu.com) Pinus 服务端 架构 MMORPG服务器架构 - I want to fly higher - BlogJava 高性能分布式游戏服务器框架_剑心！的博客-CSDN 压测 TODO robot 工具 弱网环境 Clumsy 安全 游戏安全实验室 “黑客”深度学习之“游戏外挂原理与实现” 源码学习 hstcscolor / awesome-gameserver-cn 中文游戏服务器资源大全 ARPG 永恒之塔开源服务器架构 https://github.com/Aion-server/Aion-unique 天堂 2 l2jserver2 https://github.com/oonym/l2InterludeServer https://github.com/Rogiel/l2jserver2 魔兽世界 server TrinityCore https://github.com/TrinityCore/TrinityCore tinyHeart https://github.com/luckykun/tinyHeart Unity3d 愤怒的小鸟 https://www.bilibili.com/video/av35565116/ 游戏门户 GameRes 游资网-游戏开发者门户 游戏学院 - 腾讯大学 书籍 2018腾讯移动游戏 技术评审标准与实践案例 《腾讯游戏开发精粹》 《腾讯游戏开发精粹Ⅱ》 Copyright © Ariescat all right reserved，powered by Gitbook最后修改时间： 2022-03-08 13:30 "},"Awesome/资料整理.html":{"url":"Awesome/资料整理.html","title":"Github","keywords":"","body":"《资料整理》 收藏从未停止， 学习从未开始。 Github 技术图谱 AobingJava / JavaFamily 【互联网一线大厂面试+学习指南】进阶知识完全扫盲：涵盖高并发、分布式、高可用、微服务等领域知识，作者风格幽默，看起来津津有味，把学习当做一种乐趣，何乐而不为，后端同学必看 附其 CSDN 博客（《吊打面试官》系列）：https://me.csdn.net/qq_35190492 CyC2018 / CS-Notes 144k star！📚 技术面试必备基础知识、Leetcode、计算机操作系统、计算机网络、系统设计 Snailclimb / JavaGuide 115k star！【Java 学习+面试指南】 一份涵盖大部分 Java 程序员所需要掌握的核心知识。 Issue 资料整理 · Issue #18 · wtysos11/blogWiki (github.com) Other jobbole / awesome-java-cn Java 资源大全中文版，包括开发库、开发工具、网站、博客、微信、微博等，由伯乐在线持续更新。 同时他还有 jobbole / awesome-python-cn，jobbole / awesome-cpp-cn xingshaocheng / architect-awesome 后端架构师技术图谱 521xueweihan / HelloGitHub 分享 github 上有趣、入门级的开源项目 github-cn github 中文社区资料推荐，确实是不容错过的好东西。 知识体系 主要看： Java 全栈知识体系 (pdai.tech) Java工程师成神之路 (gitee.io) 算法： labuladong 的算法小抄 (gitee.io) 代码随想录 (programmercarl.com) 极客时间 技术文章摘抄，以后端技术的广度来说真的是挺夸张的。 技术团队 美团技术团队 有赞团队 虫洞栈，京东架构师博客，包括设计模式、Springboot和Netty等源码知识 小米信息部技术团队 博主 阮一峰的网络日志 (ruanyifeng.com) 廖雪峰的官方网站 (liaoxuefeng.com) 漫话编程的博客_CSDN博客-领域博主 Zacard's Notes 克鲁斯卡尔的博客 (novoland.github.io) 面试 技术问题 Java 面经汇总 ImportNew Java 线程面试题 Top 50 - ImportNew Java并发编程73道面试题及答案 —— 面试稳了 掘金 Java 面试通关要点汇总集 - 掘金 JavaEE 面试题收集 - 掘金 2020 年收录： 强烈推荐！15 个 Github 顶级 Java 教程类开源项目推荐！ Java 基础知识面试题（2020 最新版） 这17件小事儿都做好，春招保你拿Offer！ (qq.com) 大厂面经 面试心得与总结—BAT、网易、蘑菇街 - ImportNew 真实面试经历：十面阿里，七面头条，六个Offer (qq.com) 【阿里 P6 面经】二本，curd 两年，疯狂复习，拿下阿里 offer 经历分享 2017 年秋季校招面经 - CSDN 博客 我的求职经历——遍览国内一流 IT 企业 (转） - lonelycatcher - 博客园 主观问题 你对 Java 的理解 介绍下工作中的一个对自己最有价值的项目，以及在这个过程中的角色（项目经历） 你在项目中遇到感觉最难Bug，怎么解决的 在项目中遇到印象最深困难，怎么解决的（最大的挑战） 犯过错误？遭遇的失败？ 你是否遇到过 CPU 100% ，如何排查与解决 你是否遇到过 内存 OOM ，如何排查与解决 你觉得你们项目还有哪些不足的地方 对敏捷开发、开发运维的实践 文章收藏 职场 如何入职心仪的游戏公司？ 游戏策划从入门到入行 我的求职经历——遍览国内一流IT企业(转） - lonelycatcher - 博客园 (cnblogs.com) 年度报告 SegmentFault 年度内容盘点 - 2016 其他 究竟怎样写代码才算是好代码 - CSDN 博客 成为 Java 顶尖程序员 ，看这 11 本书就够了 - CSDN 博客 简历 超级简历WonderCV - HR推荐简历模板,智能简历制作工具,专业中英文简历模板免费下载 简历模板 - 代码随想录 (programmercarl.com) Copyright © Ariescat all right reserved，powered by Gitbook最后修改时间： 2022-03-08 13:30 "},"Reading/公众号.html":{"url":"Reading/公众号.html","title":"公众号","keywords":"","body":"《公众号》 码农的荒岛求生 #高并发&高性能 看完这篇还不懂高并发中的线程与线程池你来打我(内含20张图) CPU 空闲时在干嘛？ 码农翻身 操作系统就是一个“死循环”！ 阿里技术 #问题排查 (qq.com) 线上故障如何快速排查？来看这套技巧大全 Copyright © Ariescat all right reserved，powered by Gitbook最后修改时间： 2022-03-08 13:30 "},"Reading/Effective Java.html":{"url":"Reading/Effective Java.html","title":"Effective Java","keywords":"","body":"Effective Java 第四章 类和接口 第 17 条：使可变性最小化 不可变对象本质上是线程安全的，它们不要求同步。 BigInteger 和 BitSet BigInteger 和 BigDecimal：BigInteger 实现了任意精度的整数运算，BigDecimal 实现了任意精度的浮点数运算。 第 18 条：复合优先于继承 只有当两者之间确实存在“ is-a ”关系的时候，类 B 才应该扩展类 A，否则 B 应该包含 A 的一个私有实例，并且暴露一个较小的、较简单的 API。 JDK 中如Stack extends Vector，Properties extends Hashtable都违反该原则，采用复合更优。 Copyright © Ariescat all right reserved，powered by Gitbook最后修改时间： 2022-03-08 13:30 "},"Reading/设计模式之美.html":{"url":"Reading/设计模式之美.html","title":"设计模式之美","keywords":"","body":"设计模式之美 01 为什么要尽早地学习并掌握设计模式相关知识 我理解的设计模式主要功能是：解耦和扩展 02 从哪些维度评判代码质量的好坏？如何具备写出高质量代码的能力？ 思从深而行从简，真正的高手能云淡风轻地用最简单的方法解决最复杂的问题。这也是一个编程老手跟编程新手的本质区别之一。 03 面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？ 贫血模型和充血模型 08 | 理论五：接口 vs 抽象类的区别？如何用普通的类模拟抽象类和接口？ 抽象：表示一种 is-a 的关系，为了解决代码复用问题；这是一种自下而上的设计思路，现有子类代码重复复，再提取； 接口：表示一种 has-a 的关系，为了解决抽象而非代码复用问题；这是一种自上而下的设计思路，先设计接口，再去考虑具体的实现； 10 | 理论七：为何说要多用组合少用继承？如何决定该用组合还是继承？ 继承最大问题： 继承层次过深，继承关系过于复杂带来的代码可读性和可维护性。 比如“鸟”：会不会飞，会不会叫，会不会下蛋 但：组合并不是完美的，继承也并非一无是处 12 | 实战一（下）：如何利用基于充血模型的 DDD 开发一个虚拟钱包系统？ Repository 的 Entity，即便它被设计成贫血模型，违反面向对象编程的封装特性，但 Entity 的生命周期是有限的。一般，它传递到 Service 后，就会转化成 Bo 或者 Domain 来继续后面的业务逻辑。其生命周期到此就结束了，并不会被到处任意修改。Controller 层的 Vo 单纯作为一种 DTO，亦是如此。 13 | 实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析？ OAuth：调用方将接口的 URL 和 Apple、密码拼接在一起，然后进行加密，生成一个 token。 OAuth2？ 17 | 理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了 LSP？ 里式替换原则（design by contract，按照协议来设计）：父类定义了函数的“约定（或协议）”，子类可以改变函数的实现逻辑，但不能改变函数原有的“约定”。如对函数输入、输出、异常的约定，注释中所罗列的特殊说明等。 Copyright © Ariescat all right reserved，powered by Gitbook最后修改时间： 2022-03-08 13:30 "},"Reading/书单.html":{"url":"Reading/书单.html","title":"技术书籍","keywords":"","body":"《书单》 技术书籍 Java 《深入理解 Java 虚拟机（第 3 版）（周志明）》 《Java 并发编程实战》 《Effective Java》 Spring 《Spring 源码深度解析 第二版》《Spring 实战》 《Spring Boot 编程思想（核心篇）》 《Spring Boot 实战》 《Spring 微服务实战》 Redis 《Redis 深度历险：核心原理与应用实践 （钱文品）》 《Redis 设计与实现》 MySQL 《高性能 MySQL》 Netty 《Netty 权威指南》 Tomcat 《Tomcat 架构解析 （刘光瑞）》 《漫画算法：小灰的算法之旅》 《架构探险分布式服务框架 （李业兵）》 Copyright © Ariescat all right reserved，powered by Gitbook最后修改时间： 2022-03-08 13:30 "}}