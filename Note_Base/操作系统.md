# 《操作系统》



## Linux



### 文件



#### Linux中“一切皆文件”是什么意思？

**说一下个人理解。**

一切皆文件是某些操作系统对资源的抽象，把资源都抽象成“文件”这么一个对象，然后就可以对这个对象做同一种操作。统一了对它们的操作方法，使得Linux具有了很高的灵活性和可扩展性。

比如对于普通文本文件来讲，可以通过 `open/read/write/close` 来打开/读取/写入/关闭。

比如对于 `Socket` 对象来讲，也可以通过 `open/read/write/close` 来打开/读取/写入/关闭。

比如，`ls` 是显示目录或者文件基本信息的，但是把进程信息抽象成文件之后，我们就可以使用 `ls /proc/xxx` 查看进程信息了，把 cpu 的信息抽象成文件用 `cat /proc/cpuinfo` 就可以查看 cpu 信息了，当然这个只能读不能改变。

再比如对于一些硬件设备比如蓝牙，摄像头等，都能通过 `open/read/write/close` 来打开/读取/写入/关闭。

也就是说像 Linux 这种奉行“一切皆文件”思想的操作系统，可以对所有资源都使用同一套 api 接口。

​    

下面的视频内容就讲到“蓝牙手柄就是个文件”，通过 `/dev/input/event20` 就可以获取手柄的输入：

[Linux中“一切皆文件”是什么意思？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/422144033/answer/2101817404)

​    

**优点：**

统一的文件操作接口

方便的文本处理和系统管理

方便的设备管理

安全性

[为什么说：Linux中一切皆文件？-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/2278310)

​    

**缺点：**

和 Windows 系统不同，Linux 系统没有盘。不利之处在于，使用任何硬件设备都必须与根目录下某一目录执行挂载操作，否则无法使用。





#### 硬链接和软链接

硬链接创建的是文件内容的多个名称，而软链接创建的是指向另一个文件的路径。

使用 `ln` 命令可以方便地创建硬链接和软链接。对于硬链接，不需要任何特殊选项；而对于软链接，则需要加上 `-s` 选项。





### 进程管理

- CPU调度

  - 什么时候会发生 CPU 调度

    1. 当进程从运行状态转到等待状态；
    2. 当进程从运行状态转到就绪状态；
    3. 当进程从等待状态转到就绪状态；
    4. 当进程从运行状态转到终止状态；

    其中发生在 1 和 4 两种情况下的调度称为「非抢占式调度」，2 和 3 两种情况下发生的调度称为「抢占式调度」。

  - 非抢占式

    当进程正在运行时，它就会一直运行，直到该进程完成或发生某个事件而被阻塞时，才会把 CPU 让给其他进程。

  * 抢占式调度

    顾名思义就是进程正在运行的时，可以被打断，使其把 CPU 让给其他进程。那抢占的原则一般有三种，分别是时间片原则、优先权原则、短作业优先原则。

  * 算法
    - 先来先服务调度算法
    - 最短作业优先调度算法
    - 高响应比优先调度算法
    - 时间片轮转调度算法
    - 最高优先级调度算法
    - 多级反馈队列调度算法

- [进程和线程](https://blog.csdn.net/weixin_43517199/article/details/89508381)

- 进程间通信

  [管道](https://www.cnblogs.com/zengyiwen/p/5755170.html)，消息队列，共享内存

- 死锁





### 内存管理

[一文带你了解，虚拟内存、内存分页、分段、段页式内存管理 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/451736494)

[操作系统就用一张大表管理内存？ (qq.com)](https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247500089&idx=1&sn=9a3fd6e585b0fd1ec528599ead6677c6&chksm=c2c5bb94f5b2328224fbc1309718ac7e022bfa32dbf3d6f593b23f2f58ffd0910fe80de05a7f&cur_album_id=2123743679373688834&scene=189#wechat_redirect)



#### 内存分段

程序是由若干个逻辑分段组成的，可由代码分段、数据分段、栈段、堆段组成。**不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。**

分段的办法很好，解决了程序本身不需要关心具体的物理内存地址的问题，但它也有一些不足之处：

- 第一个就是**内存碎片**的问题。
- 第二个就是**内存交换的效率低**的问题。

  

##### 内存碎片的问题

这里的内存碎片的问题共有两处地方：

- 外部内存碎片，也就是产生了多个不连续的小物理内存，导致新的程序无法被装载；
- 内部内存碎片，程序所有的内存都被装载到了物理内存，但是这个程序有部分的内存可能并不是很常使用，这也会导致内存的浪费；

解决外部内存碎片的问题就是**内存交换**。

可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们**不能装载回原来的位置**，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的时间 256MB 空间，于是新的 200MB 程序就可以装载进来。

这个内存交换空间，在 Linux 系统里，也就是我们经常看到的 **Swap 空间**，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换





#### 内存分页

让需要交换的写入或者从磁盘装载的数据更少一点，能少出现一些内存碎片。这个办法，也就是**内存分页**（*Paging*）。

​    

**页、块、页表**

将虚拟地址空间以512Byte ~ 8K，作为一个单位，称为**页**，并从0开始依次对每一个页编号。在 Linux 下，每一页的大小为 4KB。

将物理地址按照同样的大小，作为一个单位，称为**框**或者**块**，也从0开始依次对每一个框编号。 

操作系统通过维护一张表，这张表上记录了每一对页和框的映射关系，这张表，称为**页表**。 

页表实际上存储在 CPU 的**内存管理单元** （*MMU*） 中，于是 CPU 就可以直接通过 MMU，找出要实际要访问的物理内存地址。

​    

**访问**

当CPU要访问一个虚拟地址空间对应的物理内存地址时，先将具体的虚拟地址A/页面大小4K，结果的商作为页表号，结果的余作为业内地址偏移。 

​    

**内存页面置换：**

- 缺页中断

  当 CPU 访问的页面不在物理内存时，便会产生一个缺页中断，请求操作系统将所缺页调入到物理内存

- 页面置换算法

  - 最佳页面置换算法（*OPT*）
  - 先进先出置换算法（*FIFO*）
  - 最近最久未使用的置换算法（*LRU*）
  - 时钟页面置换算法（*Lock*）
  - 最不常用置换算法（*LFU*）





#### 其他

- Out of memory: Kill process

  Linux有一个特性：OOM Killer，一个保护机制，用于避免在内存不足的时候不至于出现严重问题，把一些无关的进程优先杀掉，即在内存严重不足时，系统为了继续运转，内核会挑选一个进程，将其杀掉，以释放内存，缓解内存不足情况，不过这种保护是有限的，不能完全的保护进程的运行。

  `[689379.844719] Out of memory: Kill process 421 (java) score 1949 or sacrifice child`
  `[689379.846596] Killed process 421 (java) total-vm:513937072kB, anon-rss:1299716kB, file-rss:30739736kB`

- dmesg

  dmesg命令显示linux内核的环形缓冲区信息，我们可以从中获得诸如系统架构、cpu、挂载的硬件，RAM等多个运行级别的大量的系统信息。

  如上面的`Out of memory: Kill process`就是这里发现的

- sawp

  开启/禁用：swapon和swapoff

- 虚拟内存和 swap 分区



### 磁盘

* 磁盘寻道算法

* 磁盘预读

  预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统**往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k）**，主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个**缺页异常**，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后**连续读取一页或几页载入内存中**，然后异常返回，程序继续运行。



### 设备

- 设备管理



### 系统监控

- 工具

  - sysstat性能监控工具

    sysstat提供了Linux性能监控工具集，包括sar、sadf、mpstat、iostat、pidstat、vmstat等，用于监控Linux系统性能和使用情况。

- 案例：

  - [定位性能问题常用方法：系统负载，CPU与进程_懒惰的劳模的博客-CSDN博客](https://blog.csdn.net/helowken2/article/details/107478974)

  - [《Linux小白入门之性能优化》 - 知乎 (zhihu.com)](https://www.zhihu.com/column/xingnengyouhua)

    该系列的替代版：[Linux性能优化.md (lianglianglee.com)](http://learn.lianglianglee.com/极客时间/Linux性能优化.md)





## Windows

- hiberfil.sys 和 pagefile.sys 占用系统空间，其分别是休眠空间和虚拟内存。

- 模拟 linux 环境
  - wsl2（Windows Subsystem for Linux，Windows下的Linux子系统）
  - cygwin64
- 虚拟机
  - VMware
  - VirtualBox





## Linux 常用服务搭建

（Nginx，Shadowsocks，Ngrok...）

- CentOS7
  - [Linux 如何查看端口状态_百度经验](https://jingyan.baidu.com/article/59703552c2fd838fc1074046.html)
  - [Linux Yum 命令使用举例_Linux 教程_Linux 公社-Linux 系统门户网站](http://www.linuxidc.com/Linux/2011-09/42108.htm)
  - [CentOS7 使用 firewalld 打开关闭防火墙与端口 - 莫小安 - 博客园](https://www.cnblogs.com/moxiaoan/p/5683743.html)
- MySql
  - [CentOS 下的 Mysql 的安装和使用 - suxiaoman - 博客园](https://www.cnblogs.com/suxiaoman/p/7693066.html)
- Jetty
  - [Centos6.8 Jetty 安装配置 - 那个汪 - 博客园](https://www.cnblogs.com/wzalex/p/6912500.html)
- Nginx
  - [Nginx 的一些基本功能 - CSDN 博客](http://blog.csdn.net/zhongguozhichuang/article/details/52816887)
- Shadowsocks
  - [记一次搭建 SS 服务器，完整的过程。，搭建 ss_Linux 教程 · 帮客之家](http://www.bkjia.com/Linuxjc/1202867.html)
  - [Centos 7 下搭建 SS - CSDN 博客](http://blog.csdn.net/u013309540/article/details/74330305)
  - [Shadowsocks - Clients](https://shadowsocks.org/en/download/clients.html)
  - [锐速 ServerSpeeder 无限带宽破解版一键安装包 (2017.6.23 更新 )-蜗牛 789](https://www.wn789.com/4678.html)
- Ngrok
  - [CentOS7.3 编译安装 go1.8.1 - Aliang Log](https://www.aliang.org/golang/go1-8-1.html)
  - [CentOS 下部署 Ngrok 服务器 - YE_NICKNAME - CSDN 博客](http://blog.csdn.net/y534560449/article/details/53513046)
  - [Centos 下自己架设 ngrok 服务器（内网测试神器） - 个人文章 - SegmentFault](https://segmentfault.com/a/1190000010338848)





## 必备软件

- 系统镜像
  - [https://msdn.itellyou.cn/](https://msdn.itellyou.cn/)
- everything
- wox（window 快速搜索文件启动程序软件）
- HTTP 接口测试工具
  - Postman