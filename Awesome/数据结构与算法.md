# 《数据结构与算法》



## 数据结构

- 链表，栈，队列

- 数组，矩阵

  差分数组

- 图

- 堆：一个可以被看做一棵树的数组

- 二叉树

  - **遍历**

    递归遍历，**非递归遍历**

  - 完全二叉树

  - 满二叉树

  - 平衡二叉树

    - AVL 树
    - 红黑树
      - [查找（一）史上最简单清晰的红黑树讲解 - CSDN 博客](http://blog.csdn.net/yang_yulei/article/details/26066409)
      - [查找（二）简单清晰的 B 树、Trie 树详解 - CSDN 博客](http://blog.csdn.net/yang_yulei/article/details/26104921)
    - Treap
    - BST

  - B 树、B-树、B+树、B*树 区别？

    1. B-tree 树即 B 树，是一种多路搜索树
    2. B 树的两个明显特点
       - 树内的每个节点都存储数据
       - 叶子节点之间无指针相邻
    3. B+树的两个明显特点
       - 数据只出现在叶子节点
       - 所有叶子节点增加了一个链指针
    4. B*树是 B+树的变体，在 B+树的非根和非叶子结点再增加指向兄弟的指针
    5. B+树相比 B 树的优势
       1. 单一节点存储更多的元素，使得查询的 IO 次数更少；
       2. 所有查询都要查找到叶子节点，查询性能稳定；
       3. 所有叶子节点形成有序链表，便于范围查询。
    6. 要了解一下他们的查找，**插入**，删除

- 跳跃表

- 布隆过滤器，位图，hyperloglog

- 倒排索引





## 算法

### 算法类型

- 常见算法

  - 排序

    八大排序算法比较：

    ![常见算法·图 1](/img/awesome/sort1.png)

    - 希尔排序

      时间复杂度？

    - 堆排序

      如何建堆 和调整堆？

    - 快排

      快排最好最坏的情况？优化方案？

    - 归并排序

    - 其他

      1. Java 中`Colletions.sort`和`Arrays.sort`分别用了什么排序算法呢

      2. [算法与数据结构](https://www.cnblogs.com/deng-tao/category/951445.html)

         这里给出了双路快排，三路快排，自底向上的归并排序算法等解析

         附：关于他双路快排的实现：

         ```c++
         while ((i < right) && (arr[i] < v)) i++;    // 使用索引 i 从左往右遍历直到 arr[i] < v
         while ((j > left + 1) && (arr[j] > v)) j--; // 使用索引 j 从右往左遍历直到 arr[j] > v
         ```

         个人认为还可以优化，把相等的情况考虑进去，如下：

         ```c++
         while ((i < right) && (arr[i] <= v)) i++;    // 使用索引 i 从左往右遍历直到 arr[i] < v
         while ((j > left + 1) && (arr[j] >= v)) j--; // 使用索引 j 从右往左遍历直到 arr[j] > v
         ```

  - 查找算法

    * 二分查找

    * 索引，倒排索引

    * 双指针

    * KPM 算法

      - [阮一峰 字符串匹配的 KMP 算法](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)

        补充：这篇博客的数组并不是 next 数组，而是"部分匹配值"数组，就是"前缀"和"后缀"的最长的共有元素的长度

      - [CSDN KMP 算法—终于全部弄懂了](https://blog.csdn.net/dark_cy/article/details/88698736)

        该博客分析了`k = next[k]`的问题

      - [kpm 算法 - u012361418 的博客 - CSDN 博客](http://blog.csdn.net/u012361418/article/details/46125439)

      - [KMP 算法及优化 - 疯狂的爱因斯坦 - SegmentFault](https://segmentfault.com/a/1190000007066358#articleHeader4)

        该博客讲解了 KPM 的优化问题

  - 树

    - 最小生成树算法：Kruskal 算法，Prim 算法

  - 图

    - 最短路径算法：**Dijkstra 算法**，Bellman-Ford 算法，Floyd 算法和 SPFA 算法

- 五大常用算法

  贪婪（贪心）算法，动态规划算法，分治算法，回溯算法以及分支限界算法

  [五大常用算法详解_高广超的博客-CSDN博客_算法](https://blog.csdn.net/beyond59241/article/details/50728614)

- 递归

  斐波那契数列，其时间复杂度和空间复杂度

- 递推

  动态规划就是递推的思想

  - [算法洗脑系列（8 篇）——第一篇 递推思想 - 一线码农 - 博客园](http://www.cnblogs.com/huangxincheng/archive/2011/12/29/2305525.html)

  - [常见动态规划问题总结](https://blog.csdn.net/mc695192383/article/details/70146579)

    [最长公共子序列与最长公共子串 (DP)](https://blog.csdn.net/u012102306/article/details/53184446)

      1. **最长递增子序列**

         **解法 1：最长公共子序列法**

         **解法 2：动态规划法（时间复杂度 O(N^2))**

         dp[i] 表示以标识为 i 的元素为递增序列结尾元素的最长递增子序列的长度

         **解法 3：O(NlgN）算法**

         b[i] 只是存储的对应长度为 i 的 LIS 的最小末尾

      2. **最长公共子序列**

         用 dp[i][j] 来表示 A 串中的前 i 个字符与 B 串中的前 j 个字符的最长公共子序列长度

      3. **最长公共子串**

         这个问题与上面的问题类似，区别点在于这里是子串，是连续的，令 dp[i][j] 表示 A 串中的以第 i - 1 个字符与 B 串中的以第 j - 1 个字符结尾的最长公共子串的长度

      4. **最小编辑代价问题**

         首先令 dp[i][j] 表示将 A 串中的前 i 个字符转换成 B 串中的前 j 个字符所需要的代价

    - [分治法的经典问题——大整数相乘](https://www.cnblogs.com/little-kwy/archive/2017/09/30/7613642.html)

- 启发式算法

  - 遗传算法（GA）
  - A* 算法（可拓展了解下 Navmesh）



### 时间空间复杂度

- 算法复杂度

  - 多项式时间

    一种是 O(1),O(log(n)),O(n^a) 等，我们把它叫做多项式级的复杂度，因为它的规模 n 出现在底数的位置；另一种是 O(a^n) 和 O(n!) 型复杂度，它是非多项式级的。后者的复杂度无论如何都远远大于前者，其复杂度计算机往往不能承受。[原文](https://www.zhihu.com/question/24653072)

    这里引出几个问题：

    1. NP 问题：就是可以（多知项式时间内）短时间内验证一个答案正确性的问题。
    2. NP 完全问题：第一个条件，可以这么说，就是道你如果能解决 A 问题，则通过 A 问题可以解决 B 问题，那么回 A 问题比 B 问题复杂，当所有的问题都可以通过 A 问题的解决而解决的话，那么 A 问题就可以称为 NP 完全问题，第二个条件，就是答 A 问题属于 NP 问题。



### 经典题目

* [最大公共子串](https://mp.weixin.qq.com/s/Yx3uRVGFYikx8gm-oi-0vg)

* [面试必备 | 不可不会的反转链表](https://mp.weixin.qq.com/s/_DJgsdhY4drJyEPN9xZX6Q)

* [看一遍就理解：动态规划详解](https://mp.weixin.qq.com/s/1dG8Dk7nZeIGHQ0Hp8gq7Q)

  青蛙跳阶问题：递归时的重复计算问题

  递增子序列：看一下解题思路：穷举分析，确定边界，找规律，确定状态转移方程

* Top K 问题



### 有意思的题目

* 摩尔投票法

  [面试题 17.10. 主要元素](https://leetcode-cn.com/problems/find-majority-element-lcci/)

  [求众数 II](https://leetcode-cn.com/problems/majority-element-ii/solution/qiu-zhong-shu-ii-by-leetcode-solution-y1rn/)



### 面试题

[微软经典面试100题系列（部分）_Jack Zhou的专栏-CSDN博客_微软面试题](https://blog.csdn.net/zhoudaxia/article/details/8884557)

[直通BAT面试算法精讲课_C++Java前端经典笔试面试题精讲_牛客网 (nowcoder.com)](https://www.nowcoder.com/courses/1)

[牛课堂系列算法讲座_牛客网 (nowcoder.com)](https://www.nowcoder.com/courses/6)



### 练习平台

- [剑指 Offer](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md)
- [LeetCode](https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md)
- [牛客笔试面试题库](https://www.nowcoder.com/contestRoom?from=cyc_github)

