# 《数据结构与算法》



## 数据结构

- 数组

  - 差分数组

  - 哈希表

  - 矩阵

  - 堆

    一个可以被看做一棵树的数组

    建堆过程？

    堆的调整？

- 队列，栈

- 链表

- 树

  - **遍历**

    前、中、后序

    递归遍历，**非递归遍历**

  - 种类

    - 二叉树，也叫二叉搜索树、二叉查找树。英文 BST (Binary Sort Tree)。

    - 平衡二叉树，全称平衡二叉搜索树，也叫AVL树。是一种自平衡的树。

    - 完全二叉树 与 满二叉树

    - B树 与 B+树

      B 树、B-树、B+树、B*树 区别？

      1. B-tree 树即 B 树，是一种多路搜索树

      2. B 树的两个明显特点

         - 树内的每个节点都存储数据

         - 叶子节点之间无指针相邻

      3. B+树的两个明显特点

         - 数据只出现在叶子节点

         - 所有叶子节点增加了一个链指针

      4. B*树是 B+树的变体，在 B+树的非根和非叶子结点再增加指向兄弟的指针

      5. B+树相比 B 树的优势

         1. 单一节点存储更多的元素，使得查询的 IO 次数更少；

         2. 所有查询都要查找到叶子节点，查询性能稳定；

         3. 所有叶子节点形成有序链表，便于范围查询。

      6. 要了解一下他们的查找，**插入**，删除

    - 2-3树 与 2-3-4树

      2-3树中每一个节点都具有两个孩子（我们称它为2节点）或三个孩子（我们称它为3节点）。

    - 红黑树

      - [查找（一）史上最简单清晰的红黑树讲解 - CSDN 博客](http://blog.csdn.net/yang_yulei/article/details/26066409)

      - [查找（二）简单清晰的 B 树、Trie 树详解 - CSDN 博客](http://blog.csdn.net/yang_yulei/article/details/26104921)

    - Treap
    
    - Trie，字典树，哈佛曼树

- 图

- 其他

  - 跳跃表
  - 布隆过滤器，位图，hyperloglog
  - 倒排索引
  - 并查集






## 算法

### 排序

- 希尔排序

  时间复杂度？

- 堆排序

  如何建堆 和调整堆？

- 快排

  选择基准的方式：固定位置、随机选取基准、三数取中（三种快排）

  快排最好最坏的情况？优化方案？

  优化方式：

  优化1：当待排序序列的长度分割到一定大小后，使用插入排序

  优化2：在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割

  优化3：优化递归操作

  优化4：使用并行或多线程处理子序列（略）

  （了解**三路快排、双基准**）

  快排是二路划分的算法。如果待排序列中重复元素过多，也会大大影响排序的性能。这时候，如果采用三路划分，则会很好的避免这个问题。

  扩展：

  [算法与数据结构](https://www.cnblogs.com/deng-tao/category/951445.html)

  这里给出了双路快排，三路快排，自底向上的归并排序算法等解析

  附：关于他双路快排的实现：

  ```c++
  while ((i < right) && (arr[i] < v)) i++;    // 使用索引 i 从左往右遍历直到 arr[i] < v
  while ((j > left + 1) && (arr[j] > v)) j--; // 使用索引 j 从右往左遍历直到 arr[j] > v
  ```

  个人认为还可以优化，把相等的情况考虑进去，如下：

  ```c++
  while ((i < right) && (arr[i] <= v)) i++;    // 使用索引 i 从左往右遍历直到 arr[i] < v
  while ((j > left + 1) && (arr[j] >= v)) j--; // 使用索引 j 从右往左遍历直到 arr[j] > v
  ```

- 归并排序

  为什么快速排序是不稳定排序，而归并排序是稳定排序呢？

- 八大排序算法比较

  时间、空间、稳定性比较

- 其他

  Java 中`Colletions.sort`和`Arrays.sort`分别用了什么排序算法呢？



### 查找

* 二分查找

  选取mid时，(r + l) / 2 这里的加法可能回产生整型溢出，

  解决办法：l + (r - l) / 2

* 索引，倒排索引

* 双指针

* KPM 算法

  - [阮一峰 字符串匹配的 KMP 算法](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)

    补充：这篇博客的数组并不是 next 数组，而是"部分匹配值"数组，就是"前缀"和"后缀"的最长的共有元素的长度

  - [CSDN KMP 算法—终于全部弄懂了](https://blog.csdn.net/dark_cy/article/details/88698736)

    该博客分析了`k = next[k]`的问题

  - [kpm 算法 - u012361418 的博客 - CSDN 博客](http://blog.csdn.net/u012361418/article/details/46125439)

  - [KMP 算法及优化 - 疯狂的爱因斯坦 - SegmentFault](https://segmentfault.com/a/1190000007066358#articleHeader4)

    该博客讲解了 KPM 的优化问题



### 树

- 深度遍历

  前序、中序、后序

  递归、非递归

- 广度遍历

- 最小生成树算法：Kruskal 算法，Prim 算法



### 图

- 最短路径算法：**Dijkstra 算法**，Bellman-Ford 算法，Floyd 算法和 SPFA 算法





### 递归、递推、动态规划

- 五大常用算法

  贪婪（贪心）算法，动态规划算法，分治算法，回溯算法以及分支限界算法

  [五大常用算法详解_高广超的博客-CSDN博客_算法](https://blog.csdn.net/beyond59241/article/details/50728614)

- 递归

  斐波那契数列，其时间复杂度和空间复杂度

- 递推

  动态规划就是递推的思想

  - [算法洗脑系列（8 篇）——第一篇 递推思想 - 一线码农 - 博客园](http://www.cnblogs.com/huangxincheng/archive/2011/12/29/2305525.html)

  - [常见动态规划问题总结](https://blog.csdn.net/mc695192383/article/details/70146579)

    [最长公共子序列与最长公共子串 (DP)](https://blog.csdn.net/u012102306/article/details/53184446)

      1. **最长递增子序列**

         **解法 1：最长公共子序列法**

         **解法 2：动态规划法（时间复杂度 O(N^2))**

         dp[i] 表示以标识为 i 的元素为递增序列结尾元素的最长递增子序列的长度

         **解法 3：O(NlgN）算法**

         b[i] 只是存储的对应长度为 i 的 LIS 的最小末尾

      2. **最长公共子序列**

         用 dp[i][j] 来表示 A 串中的前 i 个字符与 B 串中的前 j 个字符的最长公共子序列长度

      3. **最长公共子串**

         这个问题与上面的问题类似，区别点在于这里是子串，是连续的，令 dp[i][j] 表示 A 串中的以第 i - 1 个字符与 B 串中的以第 j - 1 个字符结尾的最长公共子串的长度

      4. **最小编辑代价问题**

         首先令 dp[i][j] 表示将 A 串中的前 i 个字符转换成 B 串中的前 j 个字符所需要的代价

    - [分治法的经典问题——大整数相乘](https://www.cnblogs.com/little-kwy/archive/2017/09/30/7613642.html)

- 启发式算法

  - 遗传算法（GA）

  - A* 算法（可拓展了解下 Navmesh）



### 时间空间复杂度

- 算法复杂度

  - 多项式时间

    一种是 O(1),O(log(n)),O(n^a) 等，我们把它叫做多项式级的复杂度，因为它的规模 n 出现在底数的位置；另一种是 O(a^n) 和 O(n!) 型复杂度，它是非多项式级的。后者的复杂度无论如何都远远大于前者，其复杂度计算机往往不能承受。[原文](https://www.zhihu.com/question/24653072)

    这里引出几个问题：

    1. NP 问题：就是可以（多知项式时间内）短时间内验证一个答案正确性的问题。

    2. NP 完全问题：第一个条件，可以这么说，就是道你如果能解决 A 问题，则通过 A 问题可以解决 B 问题，那么回 A 问题比 B 问题复杂，当所有的问题都可以通过 A 问题的解决而解决的话，那么 A 问题就可以称为 NP 完全问题，第二个条件，就是答 A 问题属于 NP 问题。





## 算法题

### 经典题目

* 经典问题之字符串

* Top K 问题

* [面试必备 | 不可不会的反转链表](https://mp.weixin.qq.com/s/_DJgsdhY4drJyEPN9xZX6Q)

* [最大公共子串](https://mp.weixin.qq.com/s/Yx3uRVGFYikx8gm-oi-0vg)

* [看一遍就理解：动态规划详解](https://mp.weixin.qq.com/s/1dG8Dk7nZeIGHQ0Hp8gq7Q)

  青蛙跳阶问题：递归时的重复计算问题

  递增子序列：看一下解题思路：穷举分析，确定边界，找规律，确定状态转移方程



### 有意思的题目

* 摩尔投票法

  [面试题 17.10. 主要元素](https://leetcode-cn.com/problems/find-majority-element-lcci/)

  [求众数 II](https://leetcode-cn.com/problems/majority-element-ii/solution/qiu-zhong-shu-ii-by-leetcode-solution-y1rn/)

- GCD，它通常表示最大公约数（greatest common divisor）

  欧几里德算法又称辗转相除法，是指用于计算两个正整数a，b的最大公约数。应用领域有数学和计算机两个方面。计算公式gcd(a,b) = gcd(b,a mod b)。



### 练习平台

- CS-Notes
  - [剑指 Offer](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md)
  - [LeetCode](https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md)

- [牛客笔试面试题库](https://www.nowcoder.com/contestRoom?from=cyc_github)





## 海量数据处理

- [advanced-java/docs/big-data](https://github.com/doocs/advanced-java/tree/main/docs/big-data)
